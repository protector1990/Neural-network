// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.5.0
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_codegen.cpp:366


#include "FT_NamingReplicationC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Messaging/Asynch_Invocation_Adapter.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/Valuetype/ValueFactory.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "FT_NamingReplicationC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\enum_typecode.cpp:29
static char const * const _tao_enumerators_FT_Naming_ChangeType[] =
  {
    "NEW",
    "UPDATED",
    "DELETED"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_FT_Naming_ChangeType (
    "IDL:FT_Naming/ChangeType:1.0",
    "ChangeType",
    _tao_enumerators_FT_Naming_ChangeType,
    3);
  

namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_ChangeType =
    &_tao_tc_FT_Naming_ChangeType;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_cs.cpp:98

FT_Naming::NotAvailable::NotAvailable (void)
  : ::CORBA::UserException (
        "IDL:FT_Naming/NotAvailable:1.0",
        "NotAvailable")
{
}

FT_Naming::NotAvailable::~NotAvailable (void)
{
}

FT_Naming::NotAvailable::NotAvailable (const ::FT_Naming::NotAvailable &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
}

FT_Naming::NotAvailable&
FT_Naming::NotAvailable::operator= (const ::FT_Naming::NotAvailable &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void FT_Naming::NotAvailable::_tao_any_destructor (void *_tao_void_pointer)
{
  NotAvailable *_tao_tmp_pointer =
    static_cast<NotAvailable *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

FT_Naming::NotAvailable *
FT_Naming::NotAvailable::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NotAvailable *> (_tao_excp);
}

const FT_Naming::NotAvailable *
FT_Naming::NotAvailable::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NotAvailable *> (_tao_excp);
}

::CORBA::Exception *FT_Naming::NotAvailable::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::FT_Naming::NotAvailable, 0);
  return retval;
}

::CORBA::Exception *
FT_Naming::NotAvailable::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::FT_Naming::NotAvailable (*this),
      0);
  return result;
}

void FT_Naming::NotAvailable::_raise (void) const
{
  throw *this;
}

void FT_Naming::NotAvailable::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void FT_Naming::NotAvailable::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr FT_Naming::NotAvailable::_tao_type (void) const
{
  return ::FT_Naming::_tc_NotAvailable;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_FT_Naming_NotAvailable = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_FT_Naming_NotAvailable (
  ::CORBA::tk_except,
  "IDL:FT_Naming/NotAvailable:1.0",
  "NotAvailable",
  _tao_fields_FT_Naming_NotAvailable,
  0);


namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_NotAvailable =
    &_tao_tc_FT_Naming_NotAvailable;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_ctor.cpp:51

FT_Naming::InvalidPeer::InvalidPeer (
    const char * _tao_reason)
  : ::CORBA::UserException (
        "IDL:FT_Naming/InvalidPeer:1.0",
        "InvalidPeer")
{
  this->reason = ::CORBA::string_dup (_tao_reason);
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_cs.cpp:98

FT_Naming::InvalidPeer::InvalidPeer (void)
  : ::CORBA::UserException (
        "IDL:FT_Naming/InvalidPeer:1.0",
        "InvalidPeer")
{
}

FT_Naming::InvalidPeer::~InvalidPeer (void)
{
}

FT_Naming::InvalidPeer::InvalidPeer (const ::FT_Naming::InvalidPeer &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
}

FT_Naming::InvalidPeer&
FT_Naming::InvalidPeer::operator= (const ::FT_Naming::InvalidPeer &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

void FT_Naming::InvalidPeer::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidPeer *_tao_tmp_pointer =
    static_cast<InvalidPeer *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

FT_Naming::InvalidPeer *
FT_Naming::InvalidPeer::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidPeer *> (_tao_excp);
}

const FT_Naming::InvalidPeer *
FT_Naming::InvalidPeer::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidPeer *> (_tao_excp);
}

::CORBA::Exception *FT_Naming::InvalidPeer::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::FT_Naming::InvalidPeer, 0);
  return retval;
}

::CORBA::Exception *
FT_Naming::InvalidPeer::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::FT_Naming::InvalidPeer (*this),
      0);
  return result;
}

void FT_Naming::InvalidPeer::_raise (void) const
{
  throw *this;
}

void FT_Naming::InvalidPeer::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void FT_Naming::InvalidPeer::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr FT_Naming::InvalidPeer::_tao_type (void) const
{
  return ::FT_Naming::_tc_InvalidPeer;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_FT_Naming_InvalidPeer[] =
      {
        { "reason", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_FT_Naming_InvalidPeer (
  ::CORBA::tk_except,
  "IDL:FT_Naming/InvalidPeer:1.0",
  "InvalidPeer",
  _tao_fields_FT_Naming_InvalidPeer,
  1);


namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_InvalidPeer =
    &_tao_tc_FT_Naming_InvalidPeer;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_FT_Naming_NamingContextUpdate[] =
      {
        { "context_name", &CORBA::_tc_string },
        { "change_type", &FT_Naming::_tc_ChangeType }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_FT_Naming_NamingContextUpdate (
  ::CORBA::tk_struct,
  "IDL:FT_Naming/NamingContextUpdate:1.0",
  "NamingContextUpdate",
  _tao_fields_FT_Naming_NamingContextUpdate,
  2);


namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_NamingContextUpdate =
    &_tao_tc_FT_Naming_NamingContextUpdate;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:56

void
FT_Naming::NamingContextUpdate::_tao_any_destructor (
    void *_tao_void_pointer)
{
  NamingContextUpdate *_tao_tmp_pointer =
    static_cast<NamingContextUpdate *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_FT_Naming_ReplicaInfo[] =
      {
        { "combined", &CORBA::_tc_boolean },
        { "root_context", &CosNaming::_tc_NamingContext },
        { "naming_manager", &FT_Naming::_tc_NamingManager }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_FT_Naming_ReplicaInfo (
  ::CORBA::tk_struct,
  "IDL:FT_Naming/ReplicaInfo:1.0",
  "ReplicaInfo",
  _tao_fields_FT_Naming_ReplicaInfo,
  3);


namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_ReplicaInfo =
    &_tao_tc_FT_Naming_ReplicaInfo;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:56

void
FT_Naming::ReplicaInfo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ReplicaInfo *_tao_tmp_pointer =
    static_cast<ReplicaInfo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_FT_Naming_ObjectGroupUpdate[] =
      {
        { "id", &PortableGroup::_tc_ObjectGroupId },
        { "change_type", &FT_Naming::_tc_ChangeType }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_FT_Naming_ObjectGroupUpdate (
  ::CORBA::tk_struct,
  "IDL:FT_Naming/ObjectGroupUpdate:1.0",
  "ObjectGroupUpdate",
  _tao_fields_FT_Naming_ObjectGroupUpdate,
  2);


namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_ObjectGroupUpdate =
    &_tao_tc_FT_Naming_ObjectGroupUpdate;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:56

void
FT_Naming::ObjectGroupUpdate::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ObjectGroupUpdate *_tao_tmp_pointer =
    static_cast<ObjectGroupUpdate *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\enum_typecode.cpp:29
static char const * const _tao_enumerators_FT_Naming_EntityKind[] =
  {
    "ctx_name",
    "obj_grp"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_FT_Naming_EntityKind (
    "IDL:FT_Naming/EntityKind:1.0",
    "EntityKind",
    _tao_enumerators_FT_Naming_EntityKind,
    2);
  

namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_EntityKind =
    &_tao_tc_FT_Naming_EntityKind;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_union\union_cs.cpp:76

FT_Naming::UpdateInfo::UpdateInfo (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (FT_Naming::EntityKind) -1;
}

FT_Naming::UpdateInfo::UpdateInfo (const ::FT_Naming::UpdateInfo &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case FT_Naming::ctx_name:
    {
      if (u.u_.ctx_ == 0)
        {
          this->u_.ctx_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.ctx_,
              FT_Naming::NamingContextUpdate (*u.u_.ctx_)
            );
        }
    }
    break;
    case FT_Naming::obj_grp:
    {
      this->u_.grp_ = u.u_.grp_;
    }
    break;
    default:
    break;
  }
}

FT_Naming::UpdateInfo::~UpdateInfo (void)
{
  // Finalize.
  this->_reset ();
}

void FT_Naming::UpdateInfo::_tao_any_destructor (void *_tao_void_pointer)
{
  UpdateInfo *tmp =
    static_cast<UpdateInfo *> (_tao_void_pointer);
  delete tmp;
}

FT_Naming::UpdateInfo &
FT_Naming::UpdateInfo::operator= (const ::FT_Naming::UpdateInfo &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case FT_Naming::ctx_name:
    {
      if (u.u_.ctx_ == 0)
        {
          this->u_.ctx_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.ctx_,
              FT_Naming::NamingContextUpdate (*u.u_.ctx_),
              *this
            );
        }
    }
    break;
    case FT_Naming::obj_grp:
    {
      this->u_.grp_ = u.u_.grp_;
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void FT_Naming::UpdateInfo::_reset (void)
{
  switch (this->disc_)
  {
    
    case FT_Naming::ctx_name:
      delete this->u_.ctx_;
      this->u_.ctx_ = 0;
      
    break;
    
    case FT_Naming::obj_grp:
      
    break;
    
    default:
    break;
  }
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\union_typecode.cpp:65

static TAO::TypeCode::Case_T<FT_Naming::EntityKind, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_FT_Naming_UpdateInfo__0 (FT_Naming::ctx_name, "ctx", &FT_Naming::_tc_NamingContextUpdate);
static TAO::TypeCode::Case_T<FT_Naming::EntityKind, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_FT_Naming_UpdateInfo__1 (FT_Naming::obj_grp, "grp", &FT_Naming::_tc_ObjectGroupUpdate);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_FT_Naming_UpdateInfo[] =
  {
    &_tao_cases_FT_Naming_UpdateInfo__0,
    &_tao_cases_FT_Naming_UpdateInfo__1
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_FT_Naming_UpdateInfo (
    "IDL:FT_Naming/UpdateInfo:1.0",
    "UpdateInfo",
    &FT_Naming::_tc_EntityKind,
    _tao_cases_FT_Naming_UpdateInfo,
    sizeof (_tao_cases_FT_Naming_UpdateInfo)/sizeof (_tao_cases_FT_Naming_UpdateInfo[0]),
    -1);
  

namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_UpdateInfo =
    &_tao_tc_FT_Naming_UpdateInfo;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\sequence_cs.cpp:105

#if !defined (_FT_NAMING_UPDATEINFOSEQ_CS_)
#define _FT_NAMING_UPDATEINFOSEQ_CS_

FT_Naming::UpdateInfoSeq::UpdateInfoSeq (void)
{}

FT_Naming::UpdateInfoSeq::UpdateInfoSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence< UpdateInfo> (max)
{}

FT_Naming::UpdateInfoSeq::UpdateInfoSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    FT_Naming::UpdateInfo * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_value_sequence< UpdateInfo>
    (max, length, buffer, release)
{}

FT_Naming::UpdateInfoSeq::UpdateInfoSeq (
    const UpdateInfoSeq &seq)
  : ::TAO::unbounded_value_sequence< UpdateInfo> (seq)
{}

FT_Naming::UpdateInfoSeq::~UpdateInfoSeq (void)
{}

void FT_Naming::UpdateInfoSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  UpdateInfoSeq * _tao_tmp_pointer =
    static_cast<UpdateInfoSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\alias_typecode.cpp:49



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_FT_Naming_UpdateInfoSeq_GUARD
#define _TAO_TYPECODE_FT_Naming_UpdateInfoSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        FT_Naming_UpdateInfoSeq_0 (
          ::CORBA::tk_sequence,
          &FT_Naming::_tc_UpdateInfo,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_FT_Naming_UpdateInfoSeq_0 =
        &FT_Naming_UpdateInfoSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_FT_Naming_UpdateInfoSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_FT_Naming_UpdateInfoSeq (
    ::CORBA::tk_alias,
    "IDL:FT_Naming/UpdateInfoSeq:1.0",
    "UpdateInfoSeq",
    &TAO::TypeCode::tc_FT_Naming_UpdateInfoSeq_0);
  

namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_UpdateInfoSeq =
    &_tao_tc_FT_Naming_UpdateInfoSeq;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_cs.cpp:48
TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for FT_Naming::UpdatePushNotifier.

FT_Naming::UpdatePushNotifier_ptr
TAO::Objref_Traits<FT_Naming::UpdatePushNotifier>::duplicate (
    FT_Naming::UpdatePushNotifier_ptr p)
{
  return FT_Naming::UpdatePushNotifier::_duplicate (p);
}

void
TAO::Objref_Traits<FT_Naming::UpdatePushNotifier>::release (
    FT_Naming::UpdatePushNotifier_ptr p)
{
  ::CORBA::release (p);
}

FT_Naming::UpdatePushNotifier_ptr
TAO::Objref_Traits<FT_Naming::UpdatePushNotifier>::nil (void)
{
  return FT_Naming::UpdatePushNotifier::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<FT_Naming::UpdatePushNotifier>::marshal (
    const FT_Naming::UpdatePushNotifier_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
FT_Naming::UpdatePushNotifier::register_peer (
  ::FT_Naming::UpdatePushNotifier_ptr peer,
  const ::FT_Naming::ReplicaInfo & info,
  ::CORBA::ULongLong initial_seq_num)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FT_Naming::UpdatePushNotifier>::in_arg_val _tao_peer (peer);
  TAO::Arg_Traits< ::FT_Naming::ReplicaInfo>::in_arg_val _tao_info (info);
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_initial_seq_num (initial_seq_num);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_peer,
      &_tao_info,
      &_tao_initial_seq_num
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "register_peer",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_ONEWAY_INVOCATION
      
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
FT_Naming::UpdatePushNotifier::notify_update (
  ::CORBA::ULongLong seq_num,
  ::FT_Naming::UpdateInfoSeq & info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_seq_num (seq_num);
  TAO::Arg_Traits< ::FT_Naming::UpdateInfoSeq>::inout_arg_val _tao_info (info);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_seq_num,
      &_tao_info
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "notify_update",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\ami_cs.cpp:55

void
FT_Naming::UpdatePushNotifier::sendc_notify_update (
  ::FT_Naming::AMI_UpdatePushNotifierHandler_ptr ami_handler,
  ::CORBA::ULongLong seq_num,
  const ::FT_Naming::UpdateInfoSeq & info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_seq_num (seq_num);
  TAO::Arg_Traits< ::FT_Naming::UpdateInfoSeq>::in_arg_val _tao_info (info);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_seq_num,
      &_tao_info
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "notify_update",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _tao_call.invoke (
      ami_handler,
      &FT_Naming::AMI_UpdatePushNotifierHandler::notify_update_reply_stub
    );
}

FT_Naming::UpdatePushNotifier::UpdatePushNotifier (void)
{
}

FT_Naming::UpdatePushNotifier::~UpdatePushNotifier (void)
{
}

void
FT_Naming::UpdatePushNotifier::_tao_any_destructor (void *_tao_void_pointer)
{
  UpdatePushNotifier *_tao_tmp_pointer =
    static_cast<UpdatePushNotifier *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

FT_Naming::UpdatePushNotifier_ptr
FT_Naming::UpdatePushNotifier::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<UpdatePushNotifier>::narrow (
        _tao_objref,
        "IDL:FT_Naming/UpdatePushNotifier:1.0");
}

FT_Naming::UpdatePushNotifier_ptr
FT_Naming::UpdatePushNotifier::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<UpdatePushNotifier>::unchecked_narrow (
        _tao_objref);
}

FT_Naming::UpdatePushNotifier_ptr
FT_Naming::UpdatePushNotifier::_nil (void)
{
  return 0;
}

FT_Naming::UpdatePushNotifier_ptr
FT_Naming::UpdatePushNotifier::_duplicate (UpdatePushNotifier_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
FT_Naming::UpdatePushNotifier::_tao_release (UpdatePushNotifier_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
FT_Naming::UpdatePushNotifier::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:FT_Naming/UpdatePushNotifier:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* FT_Naming::UpdatePushNotifier::_interface_repository_id (void) const
{
  return "IDL:FT_Naming/UpdatePushNotifier:1.0";
}

::CORBA::Boolean
FT_Naming::UpdatePushNotifier::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_FT_Naming_UpdatePushNotifier (
    ::CORBA::tk_objref,
    "IDL:FT_Naming/UpdatePushNotifier:1.0",
    "UpdatePushNotifier");
  

namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_UpdatePushNotifier =
    &_tao_tc_FT_Naming_UpdatePushNotifier;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_cs.cpp:48
TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for FT_Naming::AMI_UpdatePushNotifierHandler.

FT_Naming::AMI_UpdatePushNotifierHandler_ptr
TAO::Objref_Traits<FT_Naming::AMI_UpdatePushNotifierHandler>::duplicate (
    FT_Naming::AMI_UpdatePushNotifierHandler_ptr p)
{
  return FT_Naming::AMI_UpdatePushNotifierHandler::_duplicate (p);
}

void
TAO::Objref_Traits<FT_Naming::AMI_UpdatePushNotifierHandler>::release (
    FT_Naming::AMI_UpdatePushNotifierHandler_ptr p)
{
  ::CORBA::release (p);
}

FT_Naming::AMI_UpdatePushNotifierHandler_ptr
TAO::Objref_Traits<FT_Naming::AMI_UpdatePushNotifierHandler>::nil (void)
{
  return FT_Naming::AMI_UpdatePushNotifierHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<FT_Naming::AMI_UpdatePushNotifierHandler>::marshal (
    const FT_Naming::AMI_UpdatePushNotifierHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
FT_Naming::AMI_UpdatePushNotifierHandler::notify_update (
  const ::FT_Naming::UpdateInfoSeq & info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FT_Naming::UpdateInfoSeq>::in_arg_val _tao_info (info);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_info
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "notify_update",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);
}

void
FT_Naming::AMI_UpdatePushNotifierHandler::notify_update_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  FT_Naming::AMI_UpdatePushNotifierHandler_var _tao_reply_handler_object =
    FT_Naming::AMI_UpdatePushNotifierHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::FT_Naming::UpdateInfoSeq info;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> info)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->notify_update (
          
          info
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->notify_update_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
FT_Naming::AMI_UpdatePushNotifierHandler::notify_update_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "notify_update_excep",
      19,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);
}

FT_Naming::AMI_UpdatePushNotifierHandler::AMI_UpdatePushNotifierHandler (void)
{
}

FT_Naming::AMI_UpdatePushNotifierHandler::~AMI_UpdatePushNotifierHandler (void)
{
}

void
FT_Naming::AMI_UpdatePushNotifierHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_UpdatePushNotifierHandler *_tao_tmp_pointer =
    static_cast<AMI_UpdatePushNotifierHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

FT_Naming::AMI_UpdatePushNotifierHandler_ptr
FT_Naming::AMI_UpdatePushNotifierHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_UpdatePushNotifierHandler>::narrow (
        _tao_objref,
        "IDL:FT_Naming/AMI_UpdatePushNotifierHandler:1.0");
}

FT_Naming::AMI_UpdatePushNotifierHandler_ptr
FT_Naming::AMI_UpdatePushNotifierHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_UpdatePushNotifierHandler>::unchecked_narrow (
        _tao_objref);
}

FT_Naming::AMI_UpdatePushNotifierHandler_ptr
FT_Naming::AMI_UpdatePushNotifierHandler::_nil (void)
{
  return 0;
}

FT_Naming::AMI_UpdatePushNotifierHandler_ptr
FT_Naming::AMI_UpdatePushNotifierHandler::_duplicate (AMI_UpdatePushNotifierHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
FT_Naming::AMI_UpdatePushNotifierHandler::_tao_release (AMI_UpdatePushNotifierHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
FT_Naming::AMI_UpdatePushNotifierHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:FT_Naming/AMI_UpdatePushNotifierHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* FT_Naming::AMI_UpdatePushNotifierHandler::_interface_repository_id (void) const
{
  return "IDL:FT_Naming/AMI_UpdatePushNotifierHandler:1.0";
}

::CORBA::Boolean
FT_Naming::AMI_UpdatePushNotifierHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_FT_Naming_AMI_UpdatePushNotifierHandler (
    ::CORBA::tk_objref,
    "IDL:FT_Naming/AMI_UpdatePushNotifierHandler:1.0",
    "AMI_UpdatePushNotifierHandler");
  

namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_AMI_UpdatePushNotifierHandler =
    &_tao_tc_FT_Naming_AMI_UpdatePushNotifierHandler;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_cs.cpp:48
TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for FT_Naming::ReplicationManager.

FT_Naming::ReplicationManager_ptr
TAO::Objref_Traits<FT_Naming::ReplicationManager>::duplicate (
    FT_Naming::ReplicationManager_ptr p)
{
  return FT_Naming::ReplicationManager::_duplicate (p);
}

void
TAO::Objref_Traits<FT_Naming::ReplicationManager>::release (
    FT_Naming::ReplicationManager_ptr p)
{
  ::CORBA::release (p);
}

FT_Naming::ReplicationManager_ptr
TAO::Objref_Traits<FT_Naming::ReplicationManager>::nil (void)
{
  return FT_Naming::ReplicationManager::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<FT_Naming::ReplicationManager>::marshal (
    const FT_Naming::ReplicationManager_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

::FT_Naming::ReplicaInfo *
FT_Naming::ReplicationManager::register_replica (
  ::FT_Naming::ReplicationManager_ptr replica,
  const ::FT_Naming::ReplicaInfo & replica_info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::FT_Naming::ReplicaInfo>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FT_Naming::ReplicationManager>::in_arg_val _tao_replica (replica);
  TAO::Arg_Traits< ::FT_Naming::ReplicaInfo>::in_arg_val _tao_replica_info (replica_info);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_replica,
      &_tao_replica_info
    };

  static TAO::Exception_Data
  _tao_FT_Naming_ReplicationManager_register_replica_exceptiondata [] = 
    {
      {
        "IDL:FT_Naming/NotAvailable:1.0",
        FT_Naming::NotAvailable::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FT_Naming::_tc_NotAvailable
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "register_replica",
      16,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_FT_Naming_ReplicationManager_register_replica_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
FT_Naming::ReplicationManager::notify_updated_object_group (
  const ::FT_Naming::ObjectGroupUpdate & group_info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FT_Naming::ObjectGroupUpdate>::in_arg_val _tao_group_info (group_info);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_group_info
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "notify_updated_object_group",
      27,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_ONEWAY_INVOCATION
      
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
FT_Naming::ReplicationManager::notify_updated_context (
  const ::FT_Naming::NamingContextUpdate & context_info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FT_Naming::NamingContextUpdate>::in_arg_val _tao_context_info (context_info);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_context_info
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "notify_updated_context",
      22,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_ONEWAY_INVOCATION
      
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\ami_cs.cpp:55

void
FT_Naming::ReplicationManager::sendc_register_replica (
  ::FT_Naming::AMI_ReplicationManagerHandler_ptr ami_handler,
  ::FT_Naming::ReplicationManager_ptr replica,
  const ::FT_Naming::ReplicaInfo & replica_info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FT_Naming::ReplicationManager>::in_arg_val _tao_replica (replica);
  TAO::Arg_Traits< ::FT_Naming::ReplicaInfo>::in_arg_val _tao_replica_info (replica_info);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      &_tao_retval,
      &_tao_replica,
      &_tao_replica_info
    };

  TAO::Asynch_Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "register_replica",
      16,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _tao_call.invoke (
      ami_handler,
      &FT_Naming::AMI_ReplicationManagerHandler::register_replica_reply_stub
    );
}

FT_Naming::ReplicationManager::ReplicationManager (void)
{
}

FT_Naming::ReplicationManager::~ReplicationManager (void)
{
}

void
FT_Naming::ReplicationManager::_tao_any_destructor (void *_tao_void_pointer)
{
  ReplicationManager *_tao_tmp_pointer =
    static_cast<ReplicationManager *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

FT_Naming::ReplicationManager_ptr
FT_Naming::ReplicationManager::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ReplicationManager>::narrow (
        _tao_objref,
        "IDL:FT_Naming/ReplicationManager:1.0");
}

FT_Naming::ReplicationManager_ptr
FT_Naming::ReplicationManager::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ReplicationManager>::unchecked_narrow (
        _tao_objref);
}

FT_Naming::ReplicationManager_ptr
FT_Naming::ReplicationManager::_nil (void)
{
  return 0;
}

FT_Naming::ReplicationManager_ptr
FT_Naming::ReplicationManager::_duplicate (ReplicationManager_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
FT_Naming::ReplicationManager::_tao_release (ReplicationManager_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
FT_Naming::ReplicationManager::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:FT_Naming/ReplicationManager:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* FT_Naming::ReplicationManager::_interface_repository_id (void) const
{
  return "IDL:FT_Naming/ReplicationManager:1.0";
}

::CORBA::Boolean
FT_Naming::ReplicationManager::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_FT_Naming_ReplicationManager (
    ::CORBA::tk_objref,
    "IDL:FT_Naming/ReplicationManager:1.0",
    "ReplicationManager");
  

namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_ReplicationManager =
    &_tao_tc_FT_Naming_ReplicationManager;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_cs.cpp:48
TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for FT_Naming::AMI_ReplicationManagerHandler.

FT_Naming::AMI_ReplicationManagerHandler_ptr
TAO::Objref_Traits<FT_Naming::AMI_ReplicationManagerHandler>::duplicate (
    FT_Naming::AMI_ReplicationManagerHandler_ptr p)
{
  return FT_Naming::AMI_ReplicationManagerHandler::_duplicate (p);
}

void
TAO::Objref_Traits<FT_Naming::AMI_ReplicationManagerHandler>::release (
    FT_Naming::AMI_ReplicationManagerHandler_ptr p)
{
  ::CORBA::release (p);
}

FT_Naming::AMI_ReplicationManagerHandler_ptr
TAO::Objref_Traits<FT_Naming::AMI_ReplicationManagerHandler>::nil (void)
{
  return FT_Naming::AMI_ReplicationManagerHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<FT_Naming::AMI_ReplicationManagerHandler>::marshal (
    const FT_Naming::AMI_ReplicationManagerHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
FT_Naming::AMI_ReplicationManagerHandler::register_replica (
  const ::FT_Naming::ReplicaInfo & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::FT_Naming::ReplicaInfo>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ami_return_val
    };

  static TAO::Exception_Data
  _tao_FT_Naming_AMI_ReplicationManagerHandler_register_replica_exceptiondata [] = 
    {
      {
        "IDL:FT_Naming/NotAvailable:1.0",
        FT_Naming::NotAvailable::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FT_Naming::_tc_NotAvailable
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "register_replica",
      16,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_FT_Naming_AMI_ReplicationManagerHandler_register_replica_exceptiondata,
      1
    );
}

void
FT_Naming::AMI_ReplicationManagerHandler::register_replica_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  FT_Naming::AMI_ReplicationManagerHandler_var _tao_reply_handler_object =
    FT_Naming::AMI_ReplicationManagerHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::FT_Naming::ReplicaInfo ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->register_replica (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] =
      {
        {
          "IDL:FT_Naming/NotAvailable:1.0",
          FT_Naming::NotAvailable::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , FT_Naming::_tc_NotAvailable
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::ULong const exceptions_count = 1;
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr = 0;
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            exceptions_count,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->register_replica_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
FT_Naming::AMI_ReplicationManagerHandler::register_replica_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_excep_holder
    };

  static TAO::Exception_Data
  _tao_FT_Naming_AMI_ReplicationManagerHandler_register_replica_excep_exceptiondata [] = 
    {
      {
        "IDL:FT_Naming/NotAvailable:1.0",
        FT_Naming::NotAvailable::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , FT_Naming::_tc_NotAvailable
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "register_replica_excep",
      22,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_FT_Naming_AMI_ReplicationManagerHandler_register_replica_excep_exceptiondata,
      1
    );
}

FT_Naming::AMI_ReplicationManagerHandler::AMI_ReplicationManagerHandler (void)
{
}

FT_Naming::AMI_ReplicationManagerHandler::~AMI_ReplicationManagerHandler (void)
{
}

void
FT_Naming::AMI_ReplicationManagerHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_ReplicationManagerHandler *_tao_tmp_pointer =
    static_cast<AMI_ReplicationManagerHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

FT_Naming::AMI_ReplicationManagerHandler_ptr
FT_Naming::AMI_ReplicationManagerHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_ReplicationManagerHandler>::narrow (
        _tao_objref,
        "IDL:FT_Naming/AMI_ReplicationManagerHandler:1.0");
}

FT_Naming::AMI_ReplicationManagerHandler_ptr
FT_Naming::AMI_ReplicationManagerHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AMI_ReplicationManagerHandler>::unchecked_narrow (
        _tao_objref);
}

FT_Naming::AMI_ReplicationManagerHandler_ptr
FT_Naming::AMI_ReplicationManagerHandler::_nil (void)
{
  return 0;
}

FT_Naming::AMI_ReplicationManagerHandler_ptr
FT_Naming::AMI_ReplicationManagerHandler::_duplicate (AMI_ReplicationManagerHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
FT_Naming::AMI_ReplicationManagerHandler::_tao_release (AMI_ReplicationManagerHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
FT_Naming::AMI_ReplicationManagerHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/Messaging/ReplyHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:FT_Naming/AMI_ReplicationManagerHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* FT_Naming::AMI_ReplicationManagerHandler::_interface_repository_id (void) const
{
  return "IDL:FT_Naming/AMI_ReplicationManagerHandler:1.0";
}

::CORBA::Boolean
FT_Naming::AMI_ReplicationManagerHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_FT_Naming_AMI_ReplicationManagerHandler (
    ::CORBA::tk_objref,
    "IDL:FT_Naming/AMI_ReplicationManagerHandler:1.0",
    "AMI_ReplicationManagerHandler");
  

namespace FT_Naming
{
  ::CORBA::TypeCode_ptr const _tc_AMI_ReplicationManagerHandler =
    &_tao_tc_FT_Naming_AMI_ReplicationManagerHandler;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_enum\any_op_cs.cpp:35

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::FT_Naming::ChangeType _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::FT_Naming::ChangeType>::insert (
        _tao_any,
        ::FT_Naming::_tc_ChangeType,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::FT_Naming::ChangeType &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::FT_Naming::ChangeType>::extract (
          _tao_any,
          ::FT_Naming::_tc_ChangeType,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::ChangeType _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<FT_Naming::ChangeType>::insert (
      _tao_any,
      FT_Naming::_tc_ChangeType,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    FT_Naming::ChangeType &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<FT_Naming::ChangeType>::extract (
        _tao_any,
        FT_Naming::_tc_ChangeType,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<FT_Naming::NotAvailable>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  

  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FT_Naming::NotAvailable &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::NotAvailable>::insert_copy (
        _tao_any,
        ::FT_Naming::NotAvailable::_tao_any_destructor,
        ::FT_Naming::_tc_NotAvailable,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::FT_Naming::NotAvailable *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::NotAvailable>::insert (
        _tao_any,
        ::FT_Naming::NotAvailable::_tao_any_destructor,
        ::FT_Naming::_tc_NotAvailable,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::FT_Naming::NotAvailable *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::FT_Naming::NotAvailable>::extract (
          _tao_any,
          ::FT_Naming::NotAvailable::_tao_any_destructor,
          ::FT_Naming::_tc_NotAvailable,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const FT_Naming::NotAvailable &_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::NotAvailable>::insert_copy (
      _tao_any,
      FT_Naming::NotAvailable::_tao_any_destructor,
      FT_Naming::_tc_NotAvailable,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::NotAvailable *_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::NotAvailable>::insert (
      _tao_any,
      FT_Naming::NotAvailable::_tao_any_destructor,
      FT_Naming::_tc_NotAvailable,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const FT_Naming::NotAvailable *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<FT_Naming::NotAvailable>::extract (
        _tao_any,
        FT_Naming::NotAvailable::_tao_any_destructor,
        FT_Naming::_tc_NotAvailable,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<FT_Naming::InvalidPeer>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  

  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FT_Naming::InvalidPeer &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::InvalidPeer>::insert_copy (
        _tao_any,
        ::FT_Naming::InvalidPeer::_tao_any_destructor,
        ::FT_Naming::_tc_InvalidPeer,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::FT_Naming::InvalidPeer *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::InvalidPeer>::insert (
        _tao_any,
        ::FT_Naming::InvalidPeer::_tao_any_destructor,
        ::FT_Naming::_tc_InvalidPeer,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::FT_Naming::InvalidPeer *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::FT_Naming::InvalidPeer>::extract (
          _tao_any,
          ::FT_Naming::InvalidPeer::_tao_any_destructor,
          ::FT_Naming::_tc_InvalidPeer,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const FT_Naming::InvalidPeer &_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::InvalidPeer>::insert_copy (
      _tao_any,
      FT_Naming::InvalidPeer::_tao_any_destructor,
      FT_Naming::_tc_InvalidPeer,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::InvalidPeer *_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::InvalidPeer>::insert (
      _tao_any,
      FT_Naming::InvalidPeer::_tao_any_destructor,
      FT_Naming::_tc_InvalidPeer,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const FT_Naming::InvalidPeer *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<FT_Naming::InvalidPeer>::extract (
        _tao_any,
        FT_Naming::InvalidPeer::_tao_any_destructor,
        FT_Naming::_tc_InvalidPeer,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FT_Naming::NamingContextUpdate &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::NamingContextUpdate>::insert_copy (
        _tao_any,
        ::FT_Naming::NamingContextUpdate::_tao_any_destructor,
        ::FT_Naming::_tc_NamingContextUpdate,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    FT_Naming::NamingContextUpdate *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::FT_Naming::NamingContextUpdate>::insert (
      _tao_any,
      ::FT_Naming::NamingContextUpdate::_tao_any_destructor,
      ::FT_Naming::_tc_NamingContextUpdate,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::FT_Naming::NamingContextUpdate *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::FT_Naming::NamingContextUpdate>::extract (
        _tao_any,
        ::FT_Naming::NamingContextUpdate::_tao_any_destructor,
        ::FT_Naming::_tc_NamingContextUpdate,
        _tao_elem);
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const FT_Naming::NamingContextUpdate &_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::NamingContextUpdate>::insert_copy (
    _tao_any,
    FT_Naming::NamingContextUpdate::_tao_any_destructor,
    FT_Naming::_tc_NamingContextUpdate,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  FT_Naming::NamingContextUpdate *_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::NamingContextUpdate>::insert (
    _tao_any,
    FT_Naming::NamingContextUpdate::_tao_any_destructor,
    FT_Naming::_tc_NamingContextUpdate,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const FT_Naming::NamingContextUpdate *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<FT_Naming::NamingContextUpdate>::extract (
      _tao_any,
      FT_Naming::NamingContextUpdate::_tao_any_destructor,
      FT_Naming::_tc_NamingContextUpdate,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FT_Naming::ReplicaInfo &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::ReplicaInfo>::insert_copy (
        _tao_any,
        ::FT_Naming::ReplicaInfo::_tao_any_destructor,
        ::FT_Naming::_tc_ReplicaInfo,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    FT_Naming::ReplicaInfo *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::FT_Naming::ReplicaInfo>::insert (
      _tao_any,
      ::FT_Naming::ReplicaInfo::_tao_any_destructor,
      ::FT_Naming::_tc_ReplicaInfo,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::FT_Naming::ReplicaInfo *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::FT_Naming::ReplicaInfo>::extract (
        _tao_any,
        ::FT_Naming::ReplicaInfo::_tao_any_destructor,
        ::FT_Naming::_tc_ReplicaInfo,
        _tao_elem);
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const FT_Naming::ReplicaInfo &_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::ReplicaInfo>::insert_copy (
    _tao_any,
    FT_Naming::ReplicaInfo::_tao_any_destructor,
    FT_Naming::_tc_ReplicaInfo,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  FT_Naming::ReplicaInfo *_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::ReplicaInfo>::insert (
    _tao_any,
    FT_Naming::ReplicaInfo::_tao_any_destructor,
    FT_Naming::_tc_ReplicaInfo,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const FT_Naming::ReplicaInfo *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<FT_Naming::ReplicaInfo>::extract (
      _tao_any,
      FT_Naming::ReplicaInfo::_tao_any_destructor,
      FT_Naming::_tc_ReplicaInfo,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FT_Naming::ObjectGroupUpdate &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::ObjectGroupUpdate>::insert_copy (
        _tao_any,
        ::FT_Naming::ObjectGroupUpdate::_tao_any_destructor,
        ::FT_Naming::_tc_ObjectGroupUpdate,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    FT_Naming::ObjectGroupUpdate *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::FT_Naming::ObjectGroupUpdate>::insert (
      _tao_any,
      ::FT_Naming::ObjectGroupUpdate::_tao_any_destructor,
      ::FT_Naming::_tc_ObjectGroupUpdate,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::FT_Naming::ObjectGroupUpdate *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::FT_Naming::ObjectGroupUpdate>::extract (
        _tao_any,
        ::FT_Naming::ObjectGroupUpdate::_tao_any_destructor,
        ::FT_Naming::_tc_ObjectGroupUpdate,
        _tao_elem);
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const FT_Naming::ObjectGroupUpdate &_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::ObjectGroupUpdate>::insert_copy (
    _tao_any,
    FT_Naming::ObjectGroupUpdate::_tao_any_destructor,
    FT_Naming::_tc_ObjectGroupUpdate,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  FT_Naming::ObjectGroupUpdate *_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::ObjectGroupUpdate>::insert (
    _tao_any,
    FT_Naming::ObjectGroupUpdate::_tao_any_destructor,
    FT_Naming::_tc_ObjectGroupUpdate,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const FT_Naming::ObjectGroupUpdate *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<FT_Naming::ObjectGroupUpdate>::extract (
      _tao_any,
      FT_Naming::ObjectGroupUpdate::_tao_any_destructor,
      FT_Naming::_tc_ObjectGroupUpdate,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_enum\any_op_cs.cpp:35

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::FT_Naming::EntityKind _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::FT_Naming::EntityKind>::insert (
        _tao_any,
        ::FT_Naming::_tc_EntityKind,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::FT_Naming::EntityKind &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::FT_Naming::EntityKind>::extract (
          _tao_any,
          ::FT_Naming::_tc_EntityKind,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::EntityKind _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<FT_Naming::EntityKind>::insert (
      _tao_any,
      FT_Naming::_tc_EntityKind,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    FT_Naming::EntityKind &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<FT_Naming::EntityKind>::extract (
        _tao_any,
        FT_Naming::_tc_EntityKind,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_union\any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FT_Naming::UpdateInfo &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::UpdateInfo>::insert_copy (
        _tao_any,
        ::FT_Naming::UpdateInfo::_tao_any_destructor,
        ::FT_Naming::_tc_UpdateInfo,
        _tao_elem
      );
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::FT_Naming::UpdateInfo *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::FT_Naming::UpdateInfo>::insert (
      _tao_any,
      ::FT_Naming::UpdateInfo::_tao_any_destructor,
      ::FT_Naming::_tc_UpdateInfo,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::FT_Naming::UpdateInfo *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::FT_Naming::UpdateInfo>::extract (
        _tao_any,
        ::FT_Naming::UpdateInfo::_tao_any_destructor,
        ::FT_Naming::_tc_UpdateInfo,
        _tao_elem);
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const FT_Naming::UpdateInfo &_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::UpdateInfo>::insert_copy (
      _tao_any,
      FT_Naming::UpdateInfo::_tao_any_destructor,
      FT_Naming::_tc_UpdateInfo,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::UpdateInfo *_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::UpdateInfo>::insert (
      _tao_any,
      FT_Naming::UpdateInfo::_tao_any_destructor,
      FT_Naming::_tc_UpdateInfo,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const FT_Naming::UpdateInfo *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<FT_Naming::UpdateInfo>::extract (
        _tao_any,
        FT_Naming::UpdateInfo::_tao_any_destructor,
        FT_Naming::_tc_UpdateInfo,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::FT_Naming::UpdateInfoSeq &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::UpdateInfoSeq>::insert_copy (
        _tao_any,
        ::FT_Naming::UpdateInfoSeq::_tao_any_destructor,
        ::FT_Naming::_tc_UpdateInfoSeq,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::FT_Naming::UpdateInfoSeq *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::FT_Naming::UpdateInfoSeq>::insert (
        _tao_any,
        ::FT_Naming::UpdateInfoSeq::_tao_any_destructor,
        ::FT_Naming::_tc_UpdateInfoSeq,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::FT_Naming::UpdateInfoSeq *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::FT_Naming::UpdateInfoSeq>::extract (
          _tao_any,
          ::FT_Naming::UpdateInfoSeq::_tao_any_destructor,
          ::FT_Naming::_tc_UpdateInfoSeq,
          _tao_elem);
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const FT_Naming::UpdateInfoSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::UpdateInfoSeq>::insert_copy (
      _tao_any,
      FT_Naming::UpdateInfoSeq::_tao_any_destructor,
      FT_Naming::_tc_UpdateInfoSeq,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::UpdateInfoSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T<FT_Naming::UpdateInfoSeq>::insert (
      _tao_any,
      FT_Naming::UpdateInfoSeq::_tao_any_destructor,
      FT_Naming::_tc_UpdateInfoSeq,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const FT_Naming::UpdateInfoSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<FT_Naming::UpdateInfoSeq>::extract (
        _tao_any,
        FT_Naming::UpdateInfoSeq::_tao_any_destructor,
        FT_Naming::_tc_UpdateInfoSeq,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<FT_Naming::UpdatePushNotifier>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      UpdatePushNotifier_ptr _tao_elem)
  {
    UpdatePushNotifier_ptr _tao_objptr =
      UpdatePushNotifier::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      UpdatePushNotifier_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<UpdatePushNotifier>::insert (
        _tao_any,
        UpdatePushNotifier::_tao_any_destructor,
        _tc_UpdatePushNotifier,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      UpdatePushNotifier_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<UpdatePushNotifier>::extract (
          _tao_any,
          UpdatePushNotifier::_tao_any_destructor,
          _tc_UpdatePushNotifier,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::UpdatePushNotifier_ptr _tao_elem)
{
  FT_Naming::UpdatePushNotifier_ptr _tao_objptr =
    FT_Naming::UpdatePushNotifier::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::UpdatePushNotifier_ptr *_tao_elem)
{
  TAO::Any_Impl_T<FT_Naming::UpdatePushNotifier>::insert (
      _tao_any,
      FT_Naming::UpdatePushNotifier::_tao_any_destructor,
      FT_Naming::_tc_UpdatePushNotifier,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    FT_Naming::UpdatePushNotifier_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<FT_Naming::UpdatePushNotifier>::extract (
        _tao_any,
        FT_Naming::UpdatePushNotifier::_tao_any_destructor,
        FT_Naming::_tc_UpdatePushNotifier,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<FT_Naming::AMI_UpdatePushNotifierHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_UpdatePushNotifierHandler_ptr _tao_elem)
  {
    AMI_UpdatePushNotifierHandler_ptr _tao_objptr =
      AMI_UpdatePushNotifierHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_UpdatePushNotifierHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_UpdatePushNotifierHandler>::insert (
        _tao_any,
        AMI_UpdatePushNotifierHandler::_tao_any_destructor,
        _tc_AMI_UpdatePushNotifierHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_UpdatePushNotifierHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_UpdatePushNotifierHandler>::extract (
          _tao_any,
          AMI_UpdatePushNotifierHandler::_tao_any_destructor,
          _tc_AMI_UpdatePushNotifierHandler,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::AMI_UpdatePushNotifierHandler_ptr _tao_elem)
{
  FT_Naming::AMI_UpdatePushNotifierHandler_ptr _tao_objptr =
    FT_Naming::AMI_UpdatePushNotifierHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::AMI_UpdatePushNotifierHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<FT_Naming::AMI_UpdatePushNotifierHandler>::insert (
      _tao_any,
      FT_Naming::AMI_UpdatePushNotifierHandler::_tao_any_destructor,
      FT_Naming::_tc_AMI_UpdatePushNotifierHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    FT_Naming::AMI_UpdatePushNotifierHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<FT_Naming::AMI_UpdatePushNotifierHandler>::extract (
        _tao_any,
        FT_Naming::AMI_UpdatePushNotifierHandler::_tao_any_destructor,
        FT_Naming::_tc_AMI_UpdatePushNotifierHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<FT_Naming::ReplicationManager>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ReplicationManager_ptr _tao_elem)
  {
    ReplicationManager_ptr _tao_objptr =
      ReplicationManager::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ReplicationManager_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ReplicationManager>::insert (
        _tao_any,
        ReplicationManager::_tao_any_destructor,
        _tc_ReplicationManager,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ReplicationManager_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ReplicationManager>::extract (
          _tao_any,
          ReplicationManager::_tao_any_destructor,
          _tc_ReplicationManager,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::ReplicationManager_ptr _tao_elem)
{
  FT_Naming::ReplicationManager_ptr _tao_objptr =
    FT_Naming::ReplicationManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::ReplicationManager_ptr *_tao_elem)
{
  TAO::Any_Impl_T<FT_Naming::ReplicationManager>::insert (
      _tao_any,
      FT_Naming::ReplicationManager::_tao_any_destructor,
      FT_Naming::_tc_ReplicationManager,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    FT_Naming::ReplicationManager_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<FT_Naming::ReplicationManager>::extract (
        _tao_any,
        FT_Naming::ReplicationManager::_tao_any_destructor,
        FT_Naming::_tc_ReplicationManager,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<FT_Naming::AMI_ReplicationManagerHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace FT_Naming
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_ReplicationManagerHandler_ptr _tao_elem)
  {
    AMI_ReplicationManagerHandler_ptr _tao_objptr =
      AMI_ReplicationManagerHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMI_ReplicationManagerHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMI_ReplicationManagerHandler>::insert (
        _tao_any,
        AMI_ReplicationManagerHandler::_tao_any_destructor,
        _tc_AMI_ReplicationManagerHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMI_ReplicationManagerHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMI_ReplicationManagerHandler>::extract (
          _tao_any,
          AMI_ReplicationManagerHandler::_tao_any_destructor,
          _tc_AMI_ReplicationManagerHandler,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::AMI_ReplicationManagerHandler_ptr _tao_elem)
{
  FT_Naming::AMI_ReplicationManagerHandler_ptr _tao_objptr =
    FT_Naming::AMI_ReplicationManagerHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    FT_Naming::AMI_ReplicationManagerHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<FT_Naming::AMI_ReplicationManagerHandler>::insert (
      _tao_any,
      FT_Naming::AMI_ReplicationManagerHandler::_tao_any_destructor,
      FT_Naming::_tc_AMI_ReplicationManagerHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    FT_Naming::AMI_ReplicationManagerHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<FT_Naming::AMI_ReplicationManagerHandler>::extract (
        _tao_any,
        FT_Naming::AMI_ReplicationManagerHandler::_tao_any_destructor,
        FT_Naming::_tc_AMI_ReplicationManagerHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_enum\cdr_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, FT_Naming::ChangeType _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, FT_Naming::ChangeType & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<FT_Naming::ChangeType> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\cdr_op_cs.cpp:48
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::NotAvailable &_tao_aggregate)
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    FT_Naming::NotAvailable&)
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\cdr_op_cs.cpp:48
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::InvalidPeer &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::InvalidPeer &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::NamingContextUpdate &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.context_name.in ()) &&
    (strm << _tao_aggregate.change_type);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::NamingContextUpdate &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.context_name.out ()) &&
    (strm >> _tao_aggregate.change_type);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::ReplicaInfo &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.combined)) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.root_context.in (),
        strm
      ) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.naming_manager.in (),
        strm
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::ReplicaInfo &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.combined)) &&
    (strm >> _tao_aggregate.root_context.out ()) &&
    (strm >> _tao_aggregate.naming_manager.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::ObjectGroupUpdate &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.id) &&
    (strm << _tao_aggregate.change_type);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::ObjectGroupUpdate &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.id) &&
    (strm >> _tao_aggregate.change_type);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_enum\cdr_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, FT_Naming::EntityKind _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, FT_Naming::EntityKind & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<FT_Naming::EntityKind> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_union\cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::UpdateInfo &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case FT_Naming::ctx_name:
      {
        result = strm << _tao_union.ctx ();
      }
      break;
    case FT_Naming::obj_grp:
      {
        result = strm << _tao_union.grp ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::UpdateInfo &_tao_union
  )
{
  FT_Naming::EntityKind _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case FT_Naming::ctx_name:
      {
        FT_Naming::NamingContextUpdate _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.ctx (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case FT_Naming::obj_grp:
      {
        FT_Naming::ObjectGroupUpdate _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.grp (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_FT_Naming_UpdateInfoSeq_CPP_
#define _TAO_CDR_OP_FT_Naming_UpdateInfoSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::UpdateInfoSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::UpdateInfoSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_FT_Naming_UpdateInfoSeq_CPP_ */

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\cdr_op_cs.cpp:51

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::UpdatePushNotifier_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::UpdatePushNotifier_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::FT_Naming::UpdatePushNotifier RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\cdr_op_cs.cpp:51

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::AMI_UpdatePushNotifierHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::AMI_UpdatePushNotifierHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::FT_Naming::AMI_UpdatePushNotifierHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\cdr_op_cs.cpp:51

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::ReplicationManager_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::ReplicationManager_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::FT_Naming::ReplicationManager RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\cdr_op_cs.cpp:51

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FT_Naming::AMI_ReplicationManagerHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FT_Naming::AMI_ReplicationManagerHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::FT_Naming::AMI_ReplicationManagerHandler RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



