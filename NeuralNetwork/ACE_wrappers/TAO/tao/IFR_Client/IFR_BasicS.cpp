// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.5.0
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/


// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_codegen.cpp:635

#ifndef _TAO_IDL_IFR_BASICS_S8XKCQ_CPP_
#define _TAO_IDL_IFR_BASICS_S8XKCQ_CPP_


#include "IFR_BasicS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_Repository_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 27, 58, 25, 58,  0,
      4, 10, 58, 20, 58, 58, 58, 58,  8, 25,
     15, 58,  0, 58, 58, 30,  0, 58, 58, 58,
     25,  0, 58, 58, 58, 58, 58, 58,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 11,
      MAX_HASH_VALUE = 57,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 3,
      WORDLIST_SIZE = 44
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"",0,0},{"",0,0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"create_array", &POA_CORBA::Repository::create_array_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
      {"create_fixed", &POA_CORBA::Repository::create_fixed_skel, 0},
      {"lookup_id", &POA_CORBA::Repository::lookup_id_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_sequence", &POA_CORBA::Repository::create_sequence_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"create_string", &POA_CORBA::Repository::create_string_skel, 0},
      {"create_wstring", &POA_CORBA::Repository::create_wstring_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"get_primitive", &POA_CORBA::Repository::get_primitive_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"get_canonical_typecode", &POA_CORBA::Repository::get_canonical_typecode_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  11,  12,  13, 
       14,  15,  16, -19,  -2, -22,  -2,  17,  18, -63,  -1,  21, -64,  24, 
       -1,  25,  -1,  26,  27,  28,  29,  30,  31,  32,  33,  -1,  34,  35, 
       36,  37,  38,  39,  -1,  40,  -1,  -1,  -1,  41,  42,  -1,  -1,  -1, 
       -1,  43, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_Repository_Perfect_Hash_OpTable tao_CORBA_Repository_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::Repository::Repository (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_Repository_optable;
}

POA_CORBA::Repository::Repository (const Repository& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::Repository::~Repository (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class lookup_id_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline lookup_id_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Contained>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Contained> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->lookup_id (
          arg_1);
    }
  
  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::Repository::lookup_id_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Contained>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_search_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_search_id
    };
  
  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    dynamic_cast<POA_CORBA::Repository *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  lookup_id_Repository command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class get_canonical_typecode_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline get_canonical_typecode_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::TypeCode>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_canonical_typecode (
          arg_1);
    }
  
  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::Repository::get_canonical_typecode_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::TypeCode>::in_arg_val _tao_tc;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_tc
    };
  
  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    dynamic_cast<POA_CORBA::Repository *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  get_canonical_typecode_Repository command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class get_primitive_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline get_primitive_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::PrimitiveDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::PrimitiveDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::PrimitiveKind>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::PrimitiveKind> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->get_primitive (
          arg_1);
    }
  
  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::Repository::get_primitive_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::PrimitiveDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::PrimitiveKind>::in_arg_val _tao_kind;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_kind
    };
  
  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    dynamic_cast<POA_CORBA::Repository *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  get_primitive_Repository command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class create_string_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_string_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StringDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::StringDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->create_string (
          arg_1);
    }
  
  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::Repository::create_string_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::StringDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    dynamic_cast<POA_CORBA::Repository *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  create_string_Repository command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class create_wstring_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_wstring_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::WstringDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::WstringDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->create_wstring (
          arg_1);
    }
  
  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::Repository::create_wstring_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::WstringDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;

  POA_CORBA::Repository * const impl =
    dynamic_cast<POA_CORBA::Repository *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  create_wstring_Repository command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class create_sequence_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_sequence_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::SequenceDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::SequenceDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->create_sequence (
          arg_1
          , arg_2);
    }
  
  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::Repository::create_sequence_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::SequenceDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_element_type;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound,
      &_tao_element_type
    };
  
  static size_t const nargs = 3;

  POA_CORBA::Repository * const impl =
    dynamic_cast<POA_CORBA::Repository *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  create_sequence_Repository command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class create_array_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_array_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ArrayDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ArrayDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->create_array (
          arg_1
          , arg_2);
    }
  
  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::Repository::create_array_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ArrayDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_length;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_element_type;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_length,
      &_tao_element_type
    };
  
  static size_t const nargs = 3;

  POA_CORBA::Repository * const impl =
    dynamic_cast<POA_CORBA::Repository *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  create_array_Repository command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class create_fixed_Repository
    : public TAO::Upcall_Command
  {
  public:
    inline create_fixed_Repository (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::FixedDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::FixedDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::UShort>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::UShort> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Short>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Short> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->create_fixed (
          arg_1
          , arg_2);
    }
  
  private:
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::Repository::create_fixed_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::FixedDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::UShort>::in_arg_val _tao_digits;
  TAO::SArg_Traits< ::CORBA::Short>::in_arg_val _tao_scale;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_digits,
      &_tao_scale
    };
  
  static size_t const nargs = 3;

  POA_CORBA::Repository * const impl =
    dynamic_cast<POA_CORBA::Repository *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  create_fixed_Repository command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::Repository::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Repository:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::Repository::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::Repository *
POA_CORBA::Repository::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::Repository STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_ModuleDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 20, 64, 10, 64,  0,
     20,  0, 64, 64, 64, 64, 64, 64, 20,  0,
      5, 64, 10, 64, 64, 15, 30, 64, 64, 64,
     10,  5, 64, 64, 64, 64, 64, 64,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 63,
      HASH_VALUE_RANGE = 60,
      DUPLICATES = 6,
      WORDLIST_SIZE = 40
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -1,  -1,  -7,  -2,   5,   6, -67, 
       -9,  -2, -65,  11,  -1, -19,  -2,  12,  13,  14,  -1,  15,  16,  17, 
       18, -73,  21,  22,  23, -26,  -2,  24,  25, -67,  28,  -1,  29, -32, 
       -2,  30,  -1,  31,  -1, -69,  -1,  -1,  -1,  34,  35,  36,  37,  -1, 
       -1,  -1,  -1,  -1,  38,  -1,  -1,  39, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ModuleDef_Perfect_Hash_OpTable tao_CORBA_ModuleDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::ModuleDef::ModuleDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ModuleDef_optable;
}

POA_CORBA::ModuleDef::ModuleDef (const ModuleDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::ModuleDef::~ModuleDef (void)
{
}


// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::ModuleDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ModuleDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::ModuleDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::ModuleDef *
POA_CORBA::ModuleDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ModuleDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_ConstantDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ConstantDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 15, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 23,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8,
      WORDLIST_SIZE = 27
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ConstantDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_get_value", &POA_CORBA::ConstantDef::_get_value_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_set_value", &POA_CORBA::ConstantDef::_set_value_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_type_def", &POA_CORBA::ConstantDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::ConstantDef::_set_type_def_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -12,  -3, -15,  -2,   4,   5,  -1,  53,   8,  48, -46,  -1, -46,  17, 
       18,  19,  -1,  20,  21,  -1,  22,  -9,  -3,  23,  -6,  -2, -24,  -2, 
      -38,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  26, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ConstantDef_Perfect_Hash_OpTable tao_CORBA_ConstantDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::ConstantDef::ConstantDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ConstantDef_optable;
}

POA_CORBA::ConstantDef::ConstantDef (const ConstantDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::ConstantDef::~ConstantDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_type_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->type ();
    }
  
  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ConstantDef::_get_type_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    dynamic_cast<POA_CORBA::ConstantDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_type_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_type_def_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_def_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->type_def ();
    }
  
  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ConstantDef::_get_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    dynamic_cast<POA_CORBA::ConstantDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_type_def_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_type_def_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_type_def_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->type_def (
        arg_1);
    }
  
  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ConstantDef::_set_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_type_def
    };
  
  static size_t const nargs = 2;

  POA_CORBA::ConstantDef * const impl =
    dynamic_cast<POA_CORBA::ConstantDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_type_def_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_value_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_value_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Any>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->value ();
    }
  
  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ConstantDef::_get_value_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Any>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ConstantDef * const impl =
    dynamic_cast<POA_CORBA::ConstantDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_value_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_value_ConstantDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_value_ConstantDef (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Any>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->value (
        arg_1);
    }
  
  private:
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ConstantDef::_set_value_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Any>::in_arg_val _tao_value;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value
    };
  
  static size_t const nargs = 2;

  POA_CORBA::ConstantDef * const impl =
    dynamic_cast<POA_CORBA::ConstantDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_value_ConstantDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::ConstantDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::ConstantDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::ConstantDef *
POA_CORBA::ConstantDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ConstantDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_StructDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_StructDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StructDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0, 61, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_StructDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 39,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 8,
      WORDLIST_SIZE = 44
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_get_members", &POA_CORBA::StructDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::StructDef::_set_members_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -7,  -3,   5,   6, -12,  -2, -66,  10,  11,  -1, -15, 
       -2, -68,  14, -64,  17,  18,  19,  20,  21,  -1,  -1,  22,  -1,  -1, 
      -24,  -2,  23,  -1, -64,  26, -29,  -2,  27,  28, -64, -31,  -2, -62, 
       33,  -1,  -1,  34,  35,  36,  -1,  -1,  37,  38,  -1,  39,  -1,  -1, 
       40,  41,  42,  -1,  43, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_StructDef_Perfect_Hash_OpTable tao_CORBA_StructDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::StructDef::StructDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_StructDef_optable;
}

POA_CORBA::StructDef::StructDef (const StructDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::StructDef::~StructDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_members_StructDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_members_StructDef (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->members ();
    }
  
  private:
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::StructDef::_get_members_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::StructDef * const impl =
    dynamic_cast<POA_CORBA::StructDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_members_StructDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_members_StructDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_members_StructDef (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->members (
        arg_1);
    }
  
  private:
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::StructDef::_set_members_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };
  
  static size_t const nargs = 2;

  POA_CORBA::StructDef * const impl =
    dynamic_cast<POA_CORBA::StructDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_members_StructDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::StructDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/StructDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::StructDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::StructDef *
POA_CORBA::StructDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::StructDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_UnionDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_UnionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86,  0, 86,  0, 86, 25,
     35,  0, 35, 86, 86, 86, 86, 86,  0,  0,
     15, 86,  0, 86, 86, 20, 45, 86, 86, 86,
      5, 25, 86, 86, 86, 86, 86, 86,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 42,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 85,
      HASH_VALUE_RANGE = 82,
      DUPLICATES = 9,
      WORDLIST_SIZE = 46
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_discriminator_type", &POA_CORBA::UnionDef::_get_discriminator_type_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"_get_members", &POA_CORBA::UnionDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::UnionDef::_set_members_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_discriminator_type_def", &POA_CORBA::UnionDef::_get_discriminator_type_def_skel, 0},
      {"_set_discriminator_type_def", &POA_CORBA::UnionDef::_set_discriminator_type_def_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -87,  10,  11,  -1,  -1, 
       -1,  -1,  -1,  -1,  12,  -1,  -1, -14,  -2,  13,  -1, -17,  -2, -91, 
      -21,  -2,  16,  -1, -92,  -1, -23,  -2,  19,  20, -95, -25,  -2, -92, 
      -88,  27,  -1,  -1,  28,  29,  30,  31,  32,  33,  34,  35,  -1,  36, 
       37,  38,  39,  -1, -40,  -2, -87,  -1,  -1,  -1,  -1,  42,  -1,  -1, 
       -1,  -1,  43,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  44, 
       -1,  45, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_UnionDef_Perfect_Hash_OpTable tao_CORBA_UnionDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::UnionDef::UnionDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_UnionDef_optable;
}

POA_CORBA::UnionDef::UnionDef (const UnionDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::UnionDef::~UnionDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_discriminator_type_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_discriminator_type_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->discriminator_type ();
    }
  
  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::UnionDef::_get_discriminator_type_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    dynamic_cast<POA_CORBA::UnionDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_discriminator_type_UnionDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_discriminator_type_def_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_discriminator_type_def_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->discriminator_type_def ();
    }
  
  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::UnionDef::_get_discriminator_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    dynamic_cast<POA_CORBA::UnionDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_discriminator_type_def_UnionDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_discriminator_type_def_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_discriminator_type_def_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->discriminator_type_def (
        arg_1);
    }
  
  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::UnionDef::_set_discriminator_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_discriminator_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_discriminator_type_def
    };
  
  static size_t const nargs = 2;

  POA_CORBA::UnionDef * const impl =
    dynamic_cast<POA_CORBA::UnionDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_discriminator_type_def_UnionDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_members_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_members_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::UnionMemberSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->members ();
    }
  
  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::UnionDef::_get_members_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::UnionDef * const impl =
    dynamic_cast<POA_CORBA::UnionDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_members_UnionDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_members_UnionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_members_UnionDef (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::UnionMemberSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->members (
        arg_1);
    }
  
  private:
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::UnionDef::_set_members_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };
  
  static size_t const nargs = 2;

  POA_CORBA::UnionDef * const impl =
    dynamic_cast<POA_CORBA::UnionDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_members_UnionDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::UnionDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/UnionDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::UnionDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::UnionDef *
POA_CORBA::UnionDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::UnionDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_EnumDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_EnumDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 10, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 25
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_get_members", &POA_CORBA::EnumDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::EnumDef::_set_members_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -13,  -2, -21,  -2,   4,   5,  -1,  55,   8,  51,  12,  -1, -48,  15, 
       16,  17,  -1,  18,  19,  -1,  20,  -1, -56,  23,  -9,  -3,  -6,  -2, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_EnumDef_Perfect_Hash_OpTable tao_CORBA_EnumDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::EnumDef::EnumDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_EnumDef_optable;
}

POA_CORBA::EnumDef::EnumDef (const EnumDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs)
{
}

POA_CORBA::EnumDef::~EnumDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_members_EnumDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_members_EnumDef (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::EnumMemberSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->members ();
    }
  
  private:
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::EnumDef::_get_members_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::EnumDef * const impl =
    dynamic_cast<POA_CORBA::EnumDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_members_EnumDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_members_EnumDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_members_EnumDef (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::EnumMemberSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->members (
        arg_1);
    }
  
  private:
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::EnumDef::_set_members_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };
  
  static size_t const nargs = 2;

  POA_CORBA::EnumDef * const impl =
    dynamic_cast<POA_CORBA::EnumDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_members_EnumDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::EnumDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/EnumDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::EnumDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::EnumDef *
POA_CORBA::EnumDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::EnumDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_AliasDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AliasDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 25
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_get_original_type_def", &POA_CORBA::AliasDef::_get_original_type_def_skel, 0},
      {"_set_original_type_def", &POA_CORBA::AliasDef::_set_original_type_def_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -13,  -2, -21,  -2,   4,   5,  -1,  55,   8,  51,  12,  -1, -48,  15, 
       16,  17,  -1,  18,  19,  -1,  20,  -1, -56,  23,  -9,  -3,  -6,  -2, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AliasDef_Perfect_Hash_OpTable tao_CORBA_AliasDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::AliasDef::AliasDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AliasDef_optable;
}

POA_CORBA::AliasDef::AliasDef (const AliasDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs)
{
}

POA_CORBA::AliasDef::~AliasDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_original_type_def_AliasDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_original_type_def_AliasDef (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->original_type_def ();
    }
  
  private:
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::AliasDef::_get_original_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::AliasDef * const impl =
    dynamic_cast<POA_CORBA::AliasDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_original_type_def_AliasDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_original_type_def_AliasDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_original_type_def_AliasDef (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->original_type_def (
        arg_1);
    }
  
  private:
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::AliasDef::_set_original_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_original_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_original_type_def
    };
  
  static size_t const nargs = 2;

  POA_CORBA::AliasDef * const impl =
    dynamic_cast<POA_CORBA::AliasDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_original_type_def_AliasDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::AliasDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AliasDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::AliasDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::AliasDef *
POA_CORBA::AliasDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::AliasDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_NativeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_NativeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_NativeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_NativeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 19,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5,
      WORDLIST_SIZE = 23
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  50,   8, -45,  12,  -1, -46,  15, 
       16,  17,  -1,  18,  19,  -1,  20,  -6,  -2,  21,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  22, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_NativeDef_Perfect_Hash_OpTable tao_CORBA_NativeDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::NativeDef::NativeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_NativeDef_optable;
}

POA_CORBA::NativeDef::NativeDef (const NativeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::TypedefDef (rhs)
{
}

POA_CORBA::NativeDef::~NativeDef (void)
{
}


// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::NativeDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/NativeDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/NativeDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::NativeDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::NativeDef *
POA_CORBA::NativeDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::NativeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21,  0, 21,  0, 21, 21,
      0, 10, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,  5, 21, 21, 21,
     21,  0, 21, 21, 21, 21, 21, 21,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 20,
      HASH_VALUE_RANGE = 16,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"",0,0},
      {"_get_kind", &POA_CORBA::PrimitiveDef::_get_kind_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable tao_CORBA_PrimitiveDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::PrimitiveDef::PrimitiveDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_PrimitiveDef_optable;
}

POA_CORBA::PrimitiveDef::PrimitiveDef (const PrimitiveDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::PrimitiveDef::~PrimitiveDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_kind_PrimitiveDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_kind_PrimitiveDef (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::PrimitiveKind>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::PrimitiveKind> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->kind ();
    }
  
  private:
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::PrimitiveDef::_get_kind_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::PrimitiveKind>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::PrimitiveDef * const impl =
    dynamic_cast<POA_CORBA::PrimitiveDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_kind_PrimitiveDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::PrimitiveDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/PrimitiveDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::PrimitiveDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::PrimitiveDef *
POA_CORBA::PrimitiveDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::PrimitiveDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_StringDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_StringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21,  0, 21,  0, 21, 21,
      0, 10, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,  5, 21, 21, 21,
     21,  0, 21, 21, 21, 21, 21, 21,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_StringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 20,
      HASH_VALUE_RANGE = 16,
      DUPLICATES = 2,
      WORDLIST_SIZE = 15
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::StringDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::StringDef::_set_bound_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -22,  -1,  -1,   9, 
       10,  11,  -1,  -1,  12,  13,  14, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_StringDef_Perfect_Hash_OpTable tao_CORBA_StringDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::StringDef::StringDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_StringDef_optable;
}

POA_CORBA::StringDef::StringDef (const StringDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::StringDef::~StringDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_bound_StringDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_bound_StringDef (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->bound ();
    }
  
  private:
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::StringDef::_get_bound_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::StringDef * const impl =
    dynamic_cast<POA_CORBA::StringDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_bound_StringDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_bound_StringDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_bound_StringDef (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->bound (
        arg_1);
    }
  
  private:
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::StringDef::_set_bound_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;

  POA_CORBA::StringDef * const impl =
    dynamic_cast<POA_CORBA::StringDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_bound_StringDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::StringDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/StringDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::StringDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::StringDef *
POA_CORBA::StringDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::StringDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_WstringDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_WstringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21,  0, 21,  0, 21, 21,
      0, 10, 21, 21, 21, 21, 21, 21, 21, 21,
     21, 21, 21, 21, 21, 21,  5, 21, 21, 21,
     21,  0, 21, 21, 21, 21, 21, 21,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 20,
      HASH_VALUE_RANGE = 16,
      DUPLICATES = 2,
      WORDLIST_SIZE = 15
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::WstringDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::WstringDef::_set_bound_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -22,  -1,  -1,   9, 
       10,  11,  -1,  -1,  12,  13,  14, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_WstringDef_Perfect_Hash_OpTable tao_CORBA_WstringDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::WstringDef::WstringDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_WstringDef_optable;
}

POA_CORBA::WstringDef::WstringDef (const WstringDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::WstringDef::~WstringDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_bound_WstringDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_bound_WstringDef (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->bound ();
    }
  
  private:
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::WstringDef::_get_bound_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::WstringDef * const impl =
    dynamic_cast<POA_CORBA::WstringDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_bound_WstringDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_bound_WstringDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_bound_WstringDef (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->bound (
        arg_1);
    }
  
  private:
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::WstringDef::_set_bound_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;

  POA_CORBA::WstringDef * const impl =
    dynamic_cast<POA_CORBA::WstringDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_bound_WstringDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::WstringDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/WstringDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::WstringDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::WstringDef *
POA_CORBA::WstringDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::WstringDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_SequenceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_SequenceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28,  0, 28,  0, 28, 28,
      0, 10,  0, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,  5, 28, 28, 28,
     28,  0, 28, 28, 28, 28, 28, 28,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 13,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 27,
      HASH_VALUE_RANGE = 23,
      DUPLICATES = 3,
      WORDLIST_SIZE = 18
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::SequenceDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::SequenceDef::_set_bound_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_get_element_type_def", &POA_CORBA::SequenceDef::_get_element_type_def_skel, 0},
      {"_set_element_type_def", &POA_CORBA::SequenceDef::_set_element_type_def_skel, 0},
      {"_get_element_type", &POA_CORBA::SequenceDef::_get_element_type_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -29,  -1,  -1,   9, 
       10,  11, -15,  -2,  12,  13,  14, -32,  -1,  -1,  -1,  -1,  -1,  17, 
      
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_SequenceDef_Perfect_Hash_OpTable tao_CORBA_SequenceDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::SequenceDef::SequenceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_SequenceDef_optable;
}

POA_CORBA::SequenceDef::SequenceDef (const SequenceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::SequenceDef::~SequenceDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_bound_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_bound_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->bound ();
    }
  
  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::SequenceDef::_get_bound_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    dynamic_cast<POA_CORBA::SequenceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_bound_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_bound_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_bound_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->bound (
        arg_1);
    }
  
  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::SequenceDef::_set_bound_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;

  POA_CORBA::SequenceDef * const impl =
    dynamic_cast<POA_CORBA::SequenceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_bound_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_element_type_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_element_type_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->element_type ();
    }
  
  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::SequenceDef::_get_element_type_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    dynamic_cast<POA_CORBA::SequenceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_element_type_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_element_type_def_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_element_type_def_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->element_type_def ();
    }
  
  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::SequenceDef::_get_element_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::SequenceDef * const impl =
    dynamic_cast<POA_CORBA::SequenceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_element_type_def_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_element_type_def_SequenceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_element_type_def_SequenceDef (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->element_type_def (
        arg_1);
    }
  
  private:
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::SequenceDef::_set_element_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_element_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_element_type_def
    };
  
  static size_t const nargs = 2;

  POA_CORBA::SequenceDef * const impl =
    dynamic_cast<POA_CORBA::SequenceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_element_type_def_SequenceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::SequenceDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::SequenceDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::SequenceDef *
POA_CORBA::SequenceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::SequenceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_ArrayDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ArrayDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 13,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3,
      WORDLIST_SIZE = 18
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_get_length", &POA_CORBA::ArrayDef::_get_length_skel, 0},
      {"_set_length", &POA_CORBA::ArrayDef::_set_length_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_get_element_type", &POA_CORBA::ArrayDef::_get_element_type_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_element_type_def", &POA_CORBA::ArrayDef::_get_element_type_def_skel, 0},
      {"_set_element_type_def", &POA_CORBA::ArrayDef::_set_element_type_def_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -9,  -2,   5,  -1,   6,  -1,   7,   8, -29,  -1,  11, 
       12,  13,  -1,  14,  15, -16,  -2, -23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ArrayDef_Perfect_Hash_OpTable tao_CORBA_ArrayDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::ArrayDef::ArrayDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ArrayDef_optable;
}

POA_CORBA::ArrayDef::ArrayDef (const ArrayDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::ArrayDef::~ArrayDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_length_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_length_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->length ();
    }
  
  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ArrayDef::_get_length_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    dynamic_cast<POA_CORBA::ArrayDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_length_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_length_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_length_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->length (
        arg_1);
    }
  
  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ArrayDef::_set_length_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_length;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_length
    };
  
  static size_t const nargs = 2;

  POA_CORBA::ArrayDef * const impl =
    dynamic_cast<POA_CORBA::ArrayDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_length_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_element_type_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_element_type_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->element_type ();
    }
  
  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ArrayDef::_get_element_type_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    dynamic_cast<POA_CORBA::ArrayDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_element_type_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_element_type_def_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_element_type_def_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->element_type_def ();
    }
  
  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ArrayDef::_get_element_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ArrayDef * const impl =
    dynamic_cast<POA_CORBA::ArrayDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_element_type_def_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_element_type_def_ArrayDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_element_type_def_ArrayDef (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->element_type_def (
        arg_1);
    }
  
  private:
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ArrayDef::_set_element_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_element_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_element_type_def
    };
  
  static size_t const nargs = 2;

  POA_CORBA::ArrayDef * const impl =
    dynamic_cast<POA_CORBA::ArrayDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_element_type_def_ArrayDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::ArrayDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::ArrayDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::ArrayDef *
POA_CORBA::ArrayDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ArrayDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0, 61, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 39,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 8,
      WORDLIST_SIZE = 44
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExceptionDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_get_members", &POA_CORBA::ExceptionDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::ExceptionDef::_set_members_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -7,  -3,   5,   6, -12,  -2, -66,  10,  11,  -1, -15, 
       -2, -68,  14, -64,  17,  18,  19,  20,  21,  -1,  -1,  22,  -1,  -1, 
      -24,  -2,  23,  -1, -64,  26, -29,  -2,  27,  28, -64, -31,  -2, -62, 
       33,  -1,  -1,  34,  35,  36,  -1,  -1,  37,  38,  -1,  39,  -1,  -1, 
       40,  41,  42,  -1,  43, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable tao_CORBA_ExceptionDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::ExceptionDef::ExceptionDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExceptionDef_optable;
}

POA_CORBA::ExceptionDef::ExceptionDef (const ExceptionDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::ExceptionDef::~ExceptionDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_type_ExceptionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_ExceptionDef (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->type ();
    }
  
  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ExceptionDef::_get_type_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ExceptionDef * const impl =
    dynamic_cast<POA_CORBA::ExceptionDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_type_ExceptionDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_members_ExceptionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_members_ExceptionDef (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->members ();
    }
  
  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ExceptionDef::_get_members_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ExceptionDef * const impl =
    dynamic_cast<POA_CORBA::ExceptionDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_members_ExceptionDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_members_ExceptionDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_members_ExceptionDef (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->members (
        arg_1);
    }
  
  private:
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ExceptionDef::_set_members_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };
  
  static size_t const nargs = 2;

  POA_CORBA::ExceptionDef * const impl =
    dynamic_cast<POA_CORBA::ExceptionDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_members_ExceptionDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::ExceptionDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::ExceptionDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::ExceptionDef *
POA_CORBA::ExceptionDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExceptionDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_AttributeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 15, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 23,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8,
      WORDLIST_SIZE = 27
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::AttributeDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::AttributeDef::_get_mode_skel, 0},
      {"_get_type", &POA_CORBA::AttributeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_type_def", &POA_CORBA::AttributeDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::AttributeDef::_set_type_def_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
       -9,  -5, -15,  -2,   4,   5,  -1,  50,   8, -45,  14,  -1, -46,  17, 
       18,  19,  -1,  20,  21,  -1,  22,  -6,  -2,  23,  -1,  -1, -24,  -2, 
      -38,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  26, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AttributeDef_Perfect_Hash_OpTable tao_CORBA_AttributeDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::AttributeDef::AttributeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AttributeDef_optable;
}

POA_CORBA::AttributeDef::AttributeDef (const AttributeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::AttributeDef::~AttributeDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_type_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->type ();
    }
  
  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::AttributeDef::_get_type_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    dynamic_cast<POA_CORBA::AttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_type_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_type_def_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_def_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->type_def ();
    }
  
  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::AttributeDef::_get_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    dynamic_cast<POA_CORBA::AttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_type_def_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_type_def_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_type_def_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->type_def (
        arg_1);
    }
  
  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::AttributeDef::_set_type_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_type_def
    };
  
  static size_t const nargs = 2;

  POA_CORBA::AttributeDef * const impl =
    dynamic_cast<POA_CORBA::AttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_type_def_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_mode_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_mode_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::AttributeMode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::AttributeMode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->mode ();
    }
  
  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::AttributeDef::_get_mode_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::AttributeMode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::AttributeDef * const impl =
    dynamic_cast<POA_CORBA::AttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_mode_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_mode_AttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_mode_AttributeDef (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->mode (
        arg_1);
    }
  
  private:
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::AttributeDef::_set_mode_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_val _tao_mode;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_mode
    };
  
  static size_t const nargs = 2;

  POA_CORBA::AttributeDef * const impl =
    dynamic_cast<POA_CORBA::AttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_mode_AttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::AttributeDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::AttributeDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::AttributeDef *
POA_CORBA::AttributeDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::AttributeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
     44, 44, 44, 44, 44,  0, 44,  0, 44, 44,
     15,  0, 25, 44, 44, 44, 44, 44, 44,  0,
      0, 44, 44, 44, 44,  0, 30, 44, 44, 44,
     44,  5, 44, 44, 44, 44, 44, 44,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 43,
      HASH_VALUE_RANGE = 40,
      DUPLICATES = 11,
      WORDLIST_SIZE = 32
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::AttributeDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::AttributeDef::_get_mode_skel, 0},
      {"_get_type", &POA_CORBA::AttributeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_get_exceptions", &POA_CORBA::ExtAttributeDef::_get_get_exceptions_skel, 0},
      {"_set_set_exceptions", &POA_CORBA::ExtAttributeDef::_set_set_exceptions_skel, 0},
      {"_get_set_exceptions", &POA_CORBA::ExtAttributeDef::_get_set_exceptions_skel, 0},
      {"_set_get_exceptions", &POA_CORBA::ExtAttributeDef::_set_get_exceptions_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"describe_attribute", &POA_CORBA::ExtAttributeDef::describe_attribute_skel, 0},
      {"_get_type_def", &POA_CORBA::AttributeDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::AttributeDef::_set_type_def_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -6,  -5,   4,   5,  -1, -12,  -2, -50,  11,  -1, -48,  -1, 
       -1,  14, -16,  -4,  15, -46, -20,  -2, -45,  22,  -1,  -1,  -1,  23, 
       24,  25,  -1,  26,  -1,  27,  -1,  -1, -28,  -2, -45,  -1,  30,  -1, 
       -1,  31, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable tao_CORBA_ExtAttributeDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::ExtAttributeDef::ExtAttributeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtAttributeDef_optable;
}

POA_CORBA::ExtAttributeDef::ExtAttributeDef (const ExtAttributeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::AttributeDef (rhs)
{
}

POA_CORBA::ExtAttributeDef::~ExtAttributeDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_get_exceptions_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_get_exceptions_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->get_exceptions ();
    }
  
  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ExtAttributeDef::_get_get_exceptions_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    dynamic_cast<POA_CORBA::ExtAttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_get_exceptions_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_get_exceptions_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_get_exceptions_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_exceptions (
        arg_1);
    }
  
  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ExtAttributeDef::_set_get_exceptions_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::in_arg_val _tao_get_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_get_exceptions
    };
  
  static size_t const nargs = 2;

  POA_CORBA::ExtAttributeDef * const impl =
    dynamic_cast<POA_CORBA::ExtAttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_get_exceptions_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_set_exceptions_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_set_exceptions_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->set_exceptions ();
    }
  
  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ExtAttributeDef::_get_set_exceptions_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    dynamic_cast<POA_CORBA::ExtAttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_set_exceptions_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_set_exceptions_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_set_exceptions_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_exceptions (
        arg_1);
    }
  
  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ExtAttributeDef::_set_set_exceptions_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ExcDescriptionSeq>::in_arg_val _tao_set_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_set_exceptions
    };
  
  static size_t const nargs = 2;

  POA_CORBA::ExtAttributeDef * const impl =
    dynamic_cast<POA_CORBA::ExtAttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_set_exceptions_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class describe_attribute_ExtAttributeDef
    : public TAO::Upcall_Command
  {
  public:
    inline describe_attribute_ExtAttributeDef (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExtAttributeDescription>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExtAttributeDescription> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->describe_attribute ();
    }
  
  private:
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::ExtAttributeDef::describe_attribute_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExtAttributeDescription>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::ExtAttributeDef * const impl =
    dynamic_cast<POA_CORBA::ExtAttributeDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  describe_attribute_ExtAttributeDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::ExtAttributeDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtAttributeDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtAttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtAttributeDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::ExtAttributeDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::ExtAttributeDef *
POA_CORBA::ExtAttributeDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExtAttributeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_OperationDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_OperationDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 29,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10,
      WORDLIST_SIZE = 33
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::OperationDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::OperationDef::_get_mode_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"_get_params", &POA_CORBA::OperationDef::_get_params_skel, 0},
      {"_set_params", &POA_CORBA::OperationDef::_set_params_skel, 0},
      {"_get_contexts", &POA_CORBA::OperationDef::_get_contexts_skel, 0},
      {"_set_contexts", &POA_CORBA::OperationDef::_set_contexts_skel, 0},
      {"_get_exceptions", &POA_CORBA::OperationDef::_get_exceptions_skel, 0},
      {"_set_exceptions", &POA_CORBA::OperationDef::_set_exceptions_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_result_def", &POA_CORBA::OperationDef::_get_result_def_skel, 0},
      {"_set_result_def", &POA_CORBA::OperationDef::_set_result_def_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_get_result", &POA_CORBA::OperationDef::_get_result_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const TAO_operation_db_entry  *resword; 

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  29:
                  resword = &wordlist[27]; break;
                case  30:
                  resword = &wordlist[28]; break;
                case  31:
                  resword = &wordlist[29]; break;
                case  32:
                  resword = &wordlist[30]; break;
                case  33:
                  resword = &wordlist[31]; break;
                case  36:
                  resword = &wordlist[32]; break;
                default: return 0;
                }
              if (*str == *resword->opname && !ACE_OS::strncmp (str + 1, resword->opname + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}

static TAO_CORBA_OperationDef_Perfect_Hash_OpTable tao_CORBA_OperationDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::OperationDef::OperationDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_OperationDef_optable;
}

POA_CORBA::OperationDef::OperationDef (const OperationDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::OperationDef::~OperationDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_result_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_result_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->result ();
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_get_result_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_result_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_result_def_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_result_def_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->result_def ();
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_get_result_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::IDLType>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_result_def_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_result_def_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_result_def_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->result_def (
        arg_1);
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_set_result_def_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_result_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_result_def
    };
  
  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_result_def_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_params_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_params_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->params ();
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_get_params_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_params_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_params_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_params_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->params (
        arg_1);
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_set_params_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_val _tao_params;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_params
    };
  
  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_params_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_mode_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_mode_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::OperationMode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::OperationMode> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->mode ();
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_get_mode_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::OperationMode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_mode_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_mode_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_mode_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::OperationMode>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::OperationMode> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->mode (
        arg_1);
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_set_mode_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::OperationMode>::in_arg_val _tao_mode;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_mode
    };
  
  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_mode_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_contexts_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_contexts_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ContextIdSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->contexts ();
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_get_contexts_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ContextIdSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_contexts_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_contexts_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_contexts_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ContextIdSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->contexts (
        arg_1);
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_set_contexts_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ContextIdSeq>::in_arg_val _tao_contexts;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_contexts
    };
  
  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_contexts_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_exceptions_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_exceptions_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->exceptions ();
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_get_exceptions_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_exceptions_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_exceptions_OperationDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_exceptions_OperationDef (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->exceptions (
        arg_1);
    }
  
  private:
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::OperationDef::_set_exceptions_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_exceptions
    };
  
  static size_t const nargs = 2;

  POA_CORBA::OperationDef * const impl =
    dynamic_cast<POA_CORBA::OperationDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_exceptions_OperationDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::OperationDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/OperationDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::OperationDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::OperationDef *
POA_CORBA::OperationDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::OperationDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81,  0, 81,  0, 81, 30,
     20,  0, 81, 81, 81, 10, 81, 81,  0,  0,
      5, 81,  0, 81, 81, 20, 35, 81, 81, 81,
     10,  5, 81, 81, 81, 81, 81, 81,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 43,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 80,
      HASH_VALUE_RANGE = 77,
      DUPLICATES = 10,
      WORDLIST_SIZE = 47
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"is_a", &POA_CORBA::InterfaceDef::is_a_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"describe_interface", &POA_CORBA::InterfaceDef::describe_interface_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::InterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::InterfaceDef::_set_base_interfaces_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::InterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::InterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -82,  10,  11,  -1,  -1, 
       12, -13,  -2, -82,  15,  -1,  16,  -1,  -1, -17,  -2, -25,  -2, -84, 
       19, -29,  -2,  20,  21,  22,  23,  -1, -32,  -3,  24,  -1, -95,  27, 
       28, -94,  -1,  31, -90,  35,  36, -37,  -2, -82,  39,  -1,  -1,  40, 
       41,  42,  43,  -1,  -1,  -1,  44,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  45,  -1,  46, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable tao_CORBA_InterfaceDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::InterfaceDef::InterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_InterfaceDef_optable;
}

POA_CORBA::InterfaceDef::InterfaceDef (const InterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::InterfaceDef::~InterfaceDef (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _get_base_interfaces_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _get_base_interfaces_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->base_interfaces ();
    }
  
  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::InterfaceDef::_get_base_interfaces_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::InterfaceDef * const impl =
    dynamic_cast<POA_CORBA::InterfaceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _get_base_interfaces_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class _set_base_interfaces_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline _set_base_interfaces_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->base_interfaces (
        arg_1);
    }
  
  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::InterfaceDef::_set_base_interfaces_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_base_interfaces;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_base_interfaces
    };
  
  static size_t const nargs = 2;

  POA_CORBA::InterfaceDef * const impl =
    dynamic_cast<POA_CORBA::InterfaceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  _set_base_interfaces_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class is_a_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline is_a_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->is_a (
          arg_1);
    }
  
  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::InterfaceDef::is_a_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_interface_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_interface_id
    };
  
  static size_t const nargs = 2;

  POA_CORBA::InterfaceDef * const impl =
    dynamic_cast<POA_CORBA::InterfaceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  is_a_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class describe_interface_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline describe_interface_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceDef::FullInterfaceDescription>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDef::FullInterfaceDescription> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->describe_interface ();
    }
  
  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::InterfaceDef::describe_interface_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDef::FullInterfaceDescription>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::InterfaceDef * const impl =
    dynamic_cast<POA_CORBA::InterfaceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  describe_interface_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class create_attribute_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline create_attribute_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::AttributeDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::AttributeDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          5);
        
      retval =
        this->servant_->create_attribute (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5);
    }
  
  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::InterfaceDef::create_attribute_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::AttributeDef>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_id;
  TAO::SArg_Traits< char *>::in_arg_val _tao_name;
  TAO::SArg_Traits< char *>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type;
  TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_val _tao_mode;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_type,
      &_tao_mode
    };
  
  static size_t const nargs = 6;

  POA_CORBA::InterfaceDef * const impl =
    dynamic_cast<POA_CORBA::InterfaceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  create_attribute_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class create_operation_InterfaceDef
    : public TAO::Upcall_Command
  {
  public:
    inline create_operation_InterfaceDef (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::OperationDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::OperationDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< ::CORBA::OperationMode>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::CORBA::OperationMode> (
          this->operation_details_,
          this->args_,
          5);
        
      TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_type arg_6 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_,
          6);
        
      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_7 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          7);
        
      TAO::SArg_Traits< ::CORBA::ContextIdSeq>::in_arg_type arg_8 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_,
          8);
        
      retval =
        this->servant_->create_operation (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6
          , arg_7
          , arg_8);
    }
  
  private:
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::InterfaceDef::create_operation_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::OperationDef>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_id;
  TAO::SArg_Traits< char *>::in_arg_val _tao_name;
  TAO::SArg_Traits< char *>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_result;
  TAO::SArg_Traits< ::CORBA::OperationMode>::in_arg_val _tao_mode;
  TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_val _tao_params;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_exceptions;
  TAO::SArg_Traits< ::CORBA::ContextIdSeq>::in_arg_val _tao_contexts;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_result,
      &_tao_mode,
      &_tao_params,
      &_tao_exceptions,
      &_tao_contexts
    };
  
  static size_t const nargs = 9;

  POA_CORBA::InterfaceDef * const impl =
    dynamic_cast<POA_CORBA::InterfaceDef *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  create_operation_InterfaceDef command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::InterfaceDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::InterfaceDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::InterfaceDef *
POA_CORBA::InterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::InterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23,  0, 23,  0, 23,  0,
      0,  0, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,  5, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 22,
      HASH_VALUE_RANGE = 18,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"",0,0},
      {"create_ext_attribute", &POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel, 0},
      {"",0,0},
      {"describe_ext_interface", &POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable tao_CORBA_InterfaceAttrExtension_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::InterfaceAttrExtension::InterfaceAttrExtension (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_InterfaceAttrExtension_optable;
}

POA_CORBA::InterfaceAttrExtension::InterfaceAttrExtension (const InterfaceAttrExtension& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CORBA::InterfaceAttrExtension::~InterfaceAttrExtension (void)
{
}

namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class describe_ext_interface_InterfaceAttrExtension
    : public TAO::Upcall_Command
  {
  public:
    inline describe_ext_interface_InterfaceAttrExtension (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->describe_ext_interface ();
    }
  
  private:
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_CORBA::InterfaceAttrExtension * const impl =
    dynamic_cast<POA_CORBA::InterfaceAttrExtension *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  describe_ext_interface_InterfaceAttrExtension command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_CORBA
{
  

  // TAO_IDL - Generated from
  // c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\upcall_command_ss.cpp:80

  class create_ext_attribute_InterfaceAttrExtension
    : public TAO::Upcall_Command
  {
  public:
    inline create_ext_attribute_InterfaceAttrExtension (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExtAttributeDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExtAttributeDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< char *>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< char *> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          5);
        
      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_6 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          6);
        
      TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_7 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          7);
        
      retval =
        this->servant_->create_ext_attribute (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6
          , arg_7);
    }
  
  private:
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_ss.cpp:168

void POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExtAttributeDef>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_id;
  TAO::SArg_Traits< char *>::in_arg_val _tao_name;
  TAO::SArg_Traits< char *>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type;
  TAO::SArg_Traits< ::CORBA::AttributeMode>::in_arg_val _tao_mode;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_get_exceptions;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_set_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_type,
      &_tao_mode,
      &_tao_get_exceptions,
      &_tao_set_exceptions
    };
  
  static size_t const nargs = 8;

  POA_CORBA::InterfaceAttrExtension * const impl =
    dynamic_cast<POA_CORBA::InterfaceAttrExtension *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  create_ext_attribute_InterfaceAttrExtension command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::InterfaceAttrExtension::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::InterfaceAttrExtension::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::InterfaceAttrExtension::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::InterfaceAttrExtension *
POA_CORBA::InterfaceAttrExtension::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::InterfaceAttrExtension STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 45,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 49
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"is_a", &POA_CORBA::InterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::InterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::InterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::InterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::InterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::InterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79, 
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21, 
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1, 
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40, 
       -2, -75,  -1, -45,  -2,  42,  -1,  43,  44, -79,  -1,  -1,  -1,  -1, 
       47,  -1,  -1,  48, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtInterfaceDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::ExtInterfaceDef::ExtInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtInterfaceDef_optable;
}

POA_CORBA::ExtInterfaceDef::ExtInterfaceDef (const ExtInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs),
    POA_CORBA::InterfaceAttrExtension (rhs)
{
}

POA_CORBA::ExtInterfaceDef::~ExtInterfaceDef (void)
{
}


// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::ExtInterfaceDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::ExtInterfaceDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::ExtInterfaceDef *
POA_CORBA::ExtInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExtInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81,  0, 81,  0, 81, 30,
     20,  0, 81, 81, 81, 10, 81, 81,  0,  0,
      5, 81,  0, 81, 81, 20, 35, 81, 81, 81,
     10,  5, 81, 81, 81, 81, 81, 81,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 43,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 80,
      HASH_VALUE_RANGE = 77,
      DUPLICATES = 10,
      WORDLIST_SIZE = 47
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"is_a", &POA_CORBA::InterfaceDef::is_a_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"describe_interface", &POA_CORBA::InterfaceDef::describe_interface_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::InterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::InterfaceDef::_set_base_interfaces_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::InterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::InterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -82,  10,  11,  -1,  -1, 
       12, -13,  -2, -82,  15,  -1,  16,  -1,  -1, -17,  -2, -25,  -2, -84, 
       19, -29,  -2,  20,  21,  22,  23,  -1, -32,  -3,  24,  -1, -95,  27, 
       28, -94,  -1,  31, -90,  35,  36, -37,  -2, -82,  39,  -1,  -1,  40, 
       41,  42,  43,  -1,  -1,  -1,  44,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  45,  -1,  46, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable tao_CORBA_AbstractInterfaceDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::AbstractInterfaceDef::AbstractInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AbstractInterfaceDef_optable;
}

POA_CORBA::AbstractInterfaceDef::AbstractInterfaceDef (const AbstractInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs)
{
}

POA_CORBA::AbstractInterfaceDef::~AbstractInterfaceDef (void)
{
}


// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::AbstractInterfaceDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::AbstractInterfaceDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::AbstractInterfaceDef *
POA_CORBA::AbstractInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::AbstractInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 45,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 49
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"is_a", &POA_CORBA::InterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::InterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::InterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::InterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::InterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::InterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79, 
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21, 
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1, 
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40, 
       -2, -75,  -1, -45,  -2,  42,  -1,  43,  44, -79,  -1,  -1,  -1,  -1, 
       47,  -1,  -1,  48, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtAbstractInterfaceDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::ExtAbstractInterfaceDef::ExtAbstractInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtAbstractInterfaceDef_optable;
}

POA_CORBA::ExtAbstractInterfaceDef::ExtAbstractInterfaceDef (const ExtAbstractInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs),
    POA_CORBA::AbstractInterfaceDef (rhs),
    POA_CORBA::InterfaceAttrExtension (rhs)
{
}

POA_CORBA::ExtAbstractInterfaceDef::~ExtAbstractInterfaceDef (void)
{
}


// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::ExtAbstractInterfaceDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtAbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::ExtAbstractInterfaceDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::ExtAbstractInterfaceDef *
POA_CORBA::ExtAbstractInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExtAbstractInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
     81, 81, 81, 81, 81,  0, 81,  0, 81, 30,
     20,  0, 81, 81, 81, 10, 81, 81,  0,  0,
      5, 81,  0, 81, 81, 20, 35, 81, 81, 81,
     10,  5, 81, 81, 81, 81, 81, 81,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 43,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 80,
      HASH_VALUE_RANGE = 77,
      DUPLICATES = 10,
      WORDLIST_SIZE = 47
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"is_a", &POA_CORBA::InterfaceDef::is_a_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"describe_interface", &POA_CORBA::InterfaceDef::describe_interface_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::InterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::InterfaceDef::_set_base_interfaces_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::InterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::InterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -82,  10,  11,  -1,  -1, 
       12, -13,  -2, -82,  15,  -1,  16,  -1,  -1, -17,  -2, -25,  -2, -84, 
       19, -29,  -2,  20,  21,  22,  23,  -1, -32,  -3,  24,  -1, -95,  27, 
       28, -94,  -1,  31, -90,  35,  36, -37,  -2, -82,  39,  -1,  -1,  40, 
       41,  42,  43,  -1,  -1,  -1,  44,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  45,  -1,  46, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable tao_CORBA_LocalInterfaceDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::LocalInterfaceDef::LocalInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_LocalInterfaceDef_optable;
}

POA_CORBA::LocalInterfaceDef::LocalInterfaceDef (const LocalInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs)
{
}

POA_CORBA::LocalInterfaceDef::~LocalInterfaceDef (void)
{
}


// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::LocalInterfaceDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::LocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/LocalInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::LocalInterfaceDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::LocalInterfaceDef *
POA_CORBA::LocalInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::LocalInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_interface.cpp:1863

class TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
    };
  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];
}

const TAO_operation_db_entry *
TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 45,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 49
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"is_a", &POA_CORBA::InterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::InterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::InterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::InterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::InterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::InterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79, 
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21, 
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1, 
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40, 
       -2, -75,  -1, -45,  -2,  42,  -1,  43,  44, -79,  -1,  -1,  -1,  -1, 
       47,  -1,  -1,  48, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !ACE_OS::strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtLocalInterfaceDef_optable;

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:90

POA_CORBA::ExtLocalInterfaceDef::ExtLocalInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtLocalInterfaceDef_optable;
}

POA_CORBA::ExtLocalInterfaceDef::ExtLocalInterfaceDef (const ExtLocalInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs),
    POA_CORBA::LocalInterfaceDef (rhs),
    POA_CORBA::InterfaceAttrExtension (rhs)
{
}

POA_CORBA::ExtLocalInterfaceDef::~ExtLocalInterfaceDef (void)
{
}


// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:163



::CORBA::Boolean POA_CORBA::ExtLocalInterfaceDef::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtLocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:423

void POA_CORBA::ExtLocalInterfaceDef::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_ss.cpp:370

CORBA::ExtLocalInterfaceDef *
POA_CORBA::ExtLocalInterfaceDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ExtLocalInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* ifndef */

