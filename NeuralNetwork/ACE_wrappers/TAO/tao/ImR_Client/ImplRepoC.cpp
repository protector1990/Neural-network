// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.5.0
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_codegen.cpp:366


#include "ImplRepoC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "ImplRepoC.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_cs.cpp:98

ImplementationRepository::AlreadyRegistered::AlreadyRegistered (void)
  : ::CORBA::UserException (
        "IDL:ImplementationRepository/AlreadyRegistered:1.0",
        "AlreadyRegistered")
{
}

ImplementationRepository::AlreadyRegistered::~AlreadyRegistered (void)
{
}

ImplementationRepository::AlreadyRegistered::AlreadyRegistered (const ::ImplementationRepository::AlreadyRegistered &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
}

ImplementationRepository::AlreadyRegistered&
ImplementationRepository::AlreadyRegistered::operator= (const ::ImplementationRepository::AlreadyRegistered &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void ImplementationRepository::AlreadyRegistered::_tao_any_destructor (void *_tao_void_pointer)
{
  AlreadyRegistered *_tao_tmp_pointer =
    static_cast<AlreadyRegistered *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

ImplementationRepository::AlreadyRegistered *
ImplementationRepository::AlreadyRegistered::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<AlreadyRegistered *> (_tao_excp);
}

const ImplementationRepository::AlreadyRegistered *
ImplementationRepository::AlreadyRegistered::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const AlreadyRegistered *> (_tao_excp);
}

::CORBA::Exception *ImplementationRepository::AlreadyRegistered::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::ImplementationRepository::AlreadyRegistered, 0);
  return retval;
}

::CORBA::Exception *
ImplementationRepository::AlreadyRegistered::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::ImplementationRepository::AlreadyRegistered (*this),
      0);
  return result;
}

void ImplementationRepository::AlreadyRegistered::_raise (void) const
{
  throw *this;
}

void ImplementationRepository::AlreadyRegistered::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void ImplementationRepository::AlreadyRegistered::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr ImplementationRepository::AlreadyRegistered::_tao_type (void) const
{
  return ::ImplementationRepository::_tc_AlreadyRegistered;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_ImplementationRepository_AlreadyRegistered = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ImplementationRepository_AlreadyRegistered (
  ::CORBA::tk_except,
  "IDL:ImplementationRepository/AlreadyRegistered:1.0",
  "AlreadyRegistered",
  _tao_fields_ImplementationRepository_AlreadyRegistered,
  0);


namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_AlreadyRegistered =
    &_tao_tc_ImplementationRepository_AlreadyRegistered;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_ctor.cpp:51

ImplementationRepository::CannotActivate::CannotActivate (
    const char * _tao_reason)
  : ::CORBA::UserException (
        "IDL:ImplementationRepository/CannotActivate:1.0",
        "CannotActivate")
{
  this->reason = ::CORBA::string_dup (_tao_reason);
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_cs.cpp:98

ImplementationRepository::CannotActivate::CannotActivate (void)
  : ::CORBA::UserException (
        "IDL:ImplementationRepository/CannotActivate:1.0",
        "CannotActivate")
{
}

ImplementationRepository::CannotActivate::~CannotActivate (void)
{
}

ImplementationRepository::CannotActivate::CannotActivate (const ::ImplementationRepository::CannotActivate &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
}

ImplementationRepository::CannotActivate&
ImplementationRepository::CannotActivate::operator= (const ::ImplementationRepository::CannotActivate &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

void ImplementationRepository::CannotActivate::_tao_any_destructor (void *_tao_void_pointer)
{
  CannotActivate *_tao_tmp_pointer =
    static_cast<CannotActivate *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

ImplementationRepository::CannotActivate *
ImplementationRepository::CannotActivate::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CannotActivate *> (_tao_excp);
}

const ImplementationRepository::CannotActivate *
ImplementationRepository::CannotActivate::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CannotActivate *> (_tao_excp);
}

::CORBA::Exception *ImplementationRepository::CannotActivate::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::ImplementationRepository::CannotActivate, 0);
  return retval;
}

::CORBA::Exception *
ImplementationRepository::CannotActivate::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::ImplementationRepository::CannotActivate (*this),
      0);
  return result;
}

void ImplementationRepository::CannotActivate::_raise (void) const
{
  throw *this;
}

void ImplementationRepository::CannotActivate::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void ImplementationRepository::CannotActivate::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr ImplementationRepository::CannotActivate::_tao_type (void) const
{
  return ::ImplementationRepository::_tc_CannotActivate;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_ImplementationRepository_CannotActivate[] =
      {
        { "reason", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ImplementationRepository_CannotActivate (
  ::CORBA::tk_except,
  "IDL:ImplementationRepository/CannotActivate:1.0",
  "CannotActivate",
  _tao_fields_ImplementationRepository_CannotActivate,
  1);


namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_CannotActivate =
    &_tao_tc_ImplementationRepository_CannotActivate;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_cs.cpp:98

ImplementationRepository::NotFound::NotFound (void)
  : ::CORBA::UserException (
        "IDL:ImplementationRepository/NotFound:1.0",
        "NotFound")
{
}

ImplementationRepository::NotFound::~NotFound (void)
{
}

ImplementationRepository::NotFound::NotFound (const ::ImplementationRepository::NotFound &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
}

ImplementationRepository::NotFound&
ImplementationRepository::NotFound::operator= (const ::ImplementationRepository::NotFound &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void ImplementationRepository::NotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  NotFound *_tao_tmp_pointer =
    static_cast<NotFound *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

ImplementationRepository::NotFound *
ImplementationRepository::NotFound::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NotFound *> (_tao_excp);
}

const ImplementationRepository::NotFound *
ImplementationRepository::NotFound::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NotFound *> (_tao_excp);
}

::CORBA::Exception *ImplementationRepository::NotFound::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::ImplementationRepository::NotFound, 0);
  return retval;
}

::CORBA::Exception *
ImplementationRepository::NotFound::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::ImplementationRepository::NotFound (*this),
      0);
  return result;
}

void ImplementationRepository::NotFound::_raise (void) const
{
  throw *this;
}

void ImplementationRepository::NotFound::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void ImplementationRepository::NotFound::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr ImplementationRepository::NotFound::_tao_type (void) const
{
  return ::ImplementationRepository::_tc_NotFound;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_ImplementationRepository_NotFound = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ImplementationRepository_NotFound (
  ::CORBA::tk_except,
  "IDL:ImplementationRepository/NotFound:1.0",
  "NotFound",
  _tao_fields_ImplementationRepository_NotFound,
  0);


namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_NotFound =
    &_tao_tc_ImplementationRepository_NotFound;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_ctor.cpp:51

ImplementationRepository::CannotComplete::CannotComplete (
    const char * _tao_reason)
  : ::CORBA::UserException (
        "IDL:ImplementationRepository/CannotComplete:1.0",
        "CannotComplete")
{
  this->reason = ::CORBA::string_dup (_tao_reason);
}



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\exception_cs.cpp:98

ImplementationRepository::CannotComplete::CannotComplete (void)
  : ::CORBA::UserException (
        "IDL:ImplementationRepository/CannotComplete:1.0",
        "CannotComplete")
{
}

ImplementationRepository::CannotComplete::~CannotComplete (void)
{
}

ImplementationRepository::CannotComplete::CannotComplete (const ::ImplementationRepository::CannotComplete &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
}

ImplementationRepository::CannotComplete&
ImplementationRepository::CannotComplete::operator= (const ::ImplementationRepository::CannotComplete &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

void ImplementationRepository::CannotComplete::_tao_any_destructor (void *_tao_void_pointer)
{
  CannotComplete *_tao_tmp_pointer =
    static_cast<CannotComplete *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

ImplementationRepository::CannotComplete *
ImplementationRepository::CannotComplete::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CannotComplete *> (_tao_excp);
}

const ImplementationRepository::CannotComplete *
ImplementationRepository::CannotComplete::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CannotComplete *> (_tao_excp);
}

::CORBA::Exception *ImplementationRepository::CannotComplete::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::ImplementationRepository::CannotComplete, 0);
  return retval;
}

::CORBA::Exception *
ImplementationRepository::CannotComplete::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::ImplementationRepository::CannotComplete (*this),
      0);
  return result;
}

void ImplementationRepository::CannotComplete::_raise (void) const
{
  throw *this;
}

void ImplementationRepository::CannotComplete::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void ImplementationRepository::CannotComplete::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr ImplementationRepository::CannotComplete::_tao_type (void) const
{
  return ::ImplementationRepository::_tc_CannotComplete;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_ImplementationRepository_CannotComplete[] =
      {
        { "reason", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ImplementationRepository_CannotComplete (
  ::CORBA::tk_except,
  "IDL:ImplementationRepository/CannotComplete:1.0",
  "CannotComplete",
  _tao_fields_ImplementationRepository_CannotComplete,
  1);


namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_CannotComplete =
    &_tao_tc_ImplementationRepository_CannotComplete;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_ImplementationRepository_EnvironmentVariable[] =
      {
        { "name", &CORBA::_tc_string },
        { "value", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ImplementationRepository_EnvironmentVariable (
  ::CORBA::tk_struct,
  "IDL:ImplementationRepository/EnvironmentVariable:1.0",
  "EnvironmentVariable",
  _tao_fields_ImplementationRepository_EnvironmentVariable,
  2);


namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_EnvironmentVariable =
    &_tao_tc_ImplementationRepository_EnvironmentVariable;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:56

void
ImplementationRepository::EnvironmentVariable::_tao_any_destructor (
    void *_tao_void_pointer)
{
  EnvironmentVariable *_tao_tmp_pointer =
    static_cast<EnvironmentVariable *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\sequence_cs.cpp:105

#if !defined (_IMPLEMENTATIONREPOSITORY_ENVIRONMENTLIST_CS_)
#define _IMPLEMENTATIONREPOSITORY_ENVIRONMENTLIST_CS_

ImplementationRepository::EnvironmentList::EnvironmentList (void)
{}

ImplementationRepository::EnvironmentList::EnvironmentList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence< EnvironmentVariable> (max)
{}

ImplementationRepository::EnvironmentList::EnvironmentList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ImplementationRepository::EnvironmentVariable * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_value_sequence< EnvironmentVariable>
    (max, length, buffer, release)
{}

ImplementationRepository::EnvironmentList::EnvironmentList (
    const EnvironmentList &seq)
  : ::TAO::unbounded_value_sequence< EnvironmentVariable> (seq)
{}

ImplementationRepository::EnvironmentList::~EnvironmentList (void)
{}

void ImplementationRepository::EnvironmentList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  EnvironmentList * _tao_tmp_pointer =
    static_cast<EnvironmentList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\alias_typecode.cpp:49



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_ImplementationRepository_EnvironmentList_GUARD
#define _TAO_TYPECODE_ImplementationRepository_EnvironmentList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        ImplementationRepository_EnvironmentList_0 (
          ::CORBA::tk_sequence,
          &ImplementationRepository::_tc_EnvironmentVariable,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_ImplementationRepository_EnvironmentList_0 =
        &ImplementationRepository_EnvironmentList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_ImplementationRepository_EnvironmentList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_ImplementationRepository_EnvironmentList (
    ::CORBA::tk_alias,
    "IDL:ImplementationRepository/EnvironmentList:1.0",
    "EnvironmentList",
    &TAO::TypeCode::tc_ImplementationRepository_EnvironmentList_0);
  

namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_EnvironmentList =
    &_tao_tc_ImplementationRepository_EnvironmentList;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\enum_typecode.cpp:29
static char const * const _tao_enumerators_ImplementationRepository_ActivationMode[] =
  {
    "NORMAL",
    "MANUAL",
    "PER_CLIENT",
    "AUTO_START"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_ImplementationRepository_ActivationMode (
    "IDL:ImplementationRepository/ActivationMode:1.0",
    "ActivationMode",
    _tao_enumerators_ImplementationRepository_ActivationMode,
    4);
  

namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_ActivationMode =
    &_tao_tc_ImplementationRepository_ActivationMode;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\typecode_defn.cpp:461

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_ImplementationRepository_StartupOptions[] =
      {
        { "command_line", &CORBA::_tc_string },
        { "environment", &ImplementationRepository::_tc_EnvironmentList },
        { "working_directory", &CORBA::_tc_string },
        { "activation", &ImplementationRepository::_tc_ActivationMode },
        { "activator", &CORBA::_tc_string },
        { "start_limit", &CORBA::_tc_long }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ImplementationRepository_StartupOptions (
  ::CORBA::tk_struct,
  "IDL:ImplementationRepository/StartupOptions:1.0",
  "StartupOptions",
  _tao_fields_ImplementationRepository_StartupOptions,
  6);


namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_StartupOptions =
    &_tao_tc_ImplementationRepository_StartupOptions;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:56

void
ImplementationRepository::StartupOptions::_tao_any_destructor (
    void *_tao_void_pointer)
{
  StartupOptions *_tao_tmp_pointer =
    static_cast<StartupOptions *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\enum_typecode.cpp:29
static char const * const _tao_enumerators_ImplementationRepository_ServerActiveStatus[] =
  {
    "ACTIVE_MAYBE",
    "ACTIVE_YES",
    "ACTIVE_NO"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_ImplementationRepository_ServerActiveStatus (
    "IDL:ImplementationRepository/ServerActiveStatus:1.0",
    "ServerActiveStatus",
    _tao_enumerators_ImplementationRepository_ServerActiveStatus,
    3);
  

namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_ServerActiveStatus =
    &_tao_tc_ImplementationRepository_ServerActiveStatus;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_ImplementationRepository_ServerInformation[] =
      {
        { "server", &CORBA::_tc_string },
        { "startup", &ImplementationRepository::_tc_StartupOptions },
        { "partial_ior", &CORBA::_tc_string },
        { "activeStatus", &ImplementationRepository::_tc_ServerActiveStatus }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ImplementationRepository_ServerInformation (
  ::CORBA::tk_struct,
  "IDL:ImplementationRepository/ServerInformation:1.0",
  "ServerInformation",
  _tao_fields_ImplementationRepository_ServerInformation,
  4);


namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_ServerInformation =
    &_tao_tc_ImplementationRepository_ServerInformation;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:56

void
ImplementationRepository::ServerInformation::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ServerInformation *_tao_tmp_pointer =
    static_cast<ServerInformation *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\sequence_cs.cpp:105

#if !defined (_IMPLEMENTATIONREPOSITORY_SERVERINFORMATIONLIST_CS_)
#define _IMPLEMENTATIONREPOSITORY_SERVERINFORMATIONLIST_CS_

ImplementationRepository::ServerInformationList::ServerInformationList (void)
{}

ImplementationRepository::ServerInformationList::ServerInformationList (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence< ServerInformation> (max)
{}

ImplementationRepository::ServerInformationList::ServerInformationList (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ImplementationRepository::ServerInformation * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_value_sequence< ServerInformation>
    (max, length, buffer, release)
{}

ImplementationRepository::ServerInformationList::ServerInformationList (
    const ServerInformationList &seq)
  : ::TAO::unbounded_value_sequence< ServerInformation> (seq)
{}

ImplementationRepository::ServerInformationList::~ServerInformationList (void)
{}

void ImplementationRepository::ServerInformationList::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ServerInformationList * _tao_tmp_pointer =
    static_cast<ServerInformationList *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\alias_typecode.cpp:49



// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_ImplementationRepository_ServerInformationList_GUARD
#define _TAO_TYPECODE_ImplementationRepository_ServerInformationList_GUARD


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        ImplementationRepository_ServerInformationList_0 (
          ::CORBA::tk_sequence,
          &ImplementationRepository::_tc_ServerInformation,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_ImplementationRepository_ServerInformationList_0 =
        &ImplementationRepository_ServerInformationList_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_TYPECODE_ImplementationRepository_ServerInformationList_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_ImplementationRepository_ServerInformationList (
    ::CORBA::tk_alias,
    "IDL:ImplementationRepository/ServerInformationList:1.0",
    "ServerInformationList",
    &TAO::TypeCode::tc_ImplementationRepository_ServerInformationList_0);
  

namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_ServerInformationList =
    &_tao_tc_ImplementationRepository_ServerInformationList;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for ImplementationRepository::ServerInformationIterator.

ImplementationRepository::ServerInformationIterator_ptr
TAO::Objref_Traits<ImplementationRepository::ServerInformationIterator>::duplicate (
    ImplementationRepository::ServerInformationIterator_ptr p)
{
  return ImplementationRepository::ServerInformationIterator::_duplicate (p);
}

void
TAO::Objref_Traits<ImplementationRepository::ServerInformationIterator>::release (
    ImplementationRepository::ServerInformationIterator_ptr p)
{
  ::CORBA::release (p);
}

ImplementationRepository::ServerInformationIterator_ptr
TAO::Objref_Traits<ImplementationRepository::ServerInformationIterator>::nil (void)
{
  return ImplementationRepository::ServerInformationIterator::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<ImplementationRepository::ServerInformationIterator>::marshal (
    const ImplementationRepository::ServerInformationIterator_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

::CORBA::Boolean
ImplementationRepository::ServerInformationIterator::next_n (
  ::CORBA::ULong how_many,
  ::ImplementationRepository::ServerInformationList_out servers)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_how_many (how_many);
  TAO::Arg_Traits< ::ImplementationRepository::ServerInformationList>::out_arg_val _tao_servers (servers);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_how_many,
      &_tao_servers
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "next_n",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::ServerInformationIterator::destroy (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "destroy",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _tao_call.invoke (0, 0);
}

ImplementationRepository::ServerInformationIterator::ServerInformationIterator (void)
{
}

ImplementationRepository::ServerInformationIterator::~ServerInformationIterator (void)
{
}

void
ImplementationRepository::ServerInformationIterator::_tao_any_destructor (void *_tao_void_pointer)
{
  ServerInformationIterator *_tao_tmp_pointer =
    static_cast<ServerInformationIterator *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

ImplementationRepository::ServerInformationIterator_ptr
ImplementationRepository::ServerInformationIterator::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ServerInformationIterator>::narrow (
        _tao_objref,
        "IDL:ImplementationRepository/ServerInformationIterator:1.0");
}

ImplementationRepository::ServerInformationIterator_ptr
ImplementationRepository::ServerInformationIterator::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<ServerInformationIterator>::unchecked_narrow (
        _tao_objref);
}

ImplementationRepository::ServerInformationIterator_ptr
ImplementationRepository::ServerInformationIterator::_nil (void)
{
  return 0;
}

ImplementationRepository::ServerInformationIterator_ptr
ImplementationRepository::ServerInformationIterator::_duplicate (ServerInformationIterator_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
ImplementationRepository::ServerInformationIterator::_tao_release (ServerInformationIterator_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
ImplementationRepository::ServerInformationIterator::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:ImplementationRepository/ServerInformationIterator:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* ImplementationRepository::ServerInformationIterator::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/ServerInformationIterator:1.0";
}

::CORBA::Boolean
ImplementationRepository::ServerInformationIterator::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_ImplementationRepository_ServerInformationIterator (
    ::CORBA::tk_objref,
    "IDL:ImplementationRepository/ServerInformationIterator:1.0",
    "ServerInformationIterator");
  

namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_ServerInformationIterator =
    &_tao_tc_ImplementationRepository_ServerInformationIterator;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for ImplementationRepository::Administration.

ImplementationRepository::Administration_ptr
TAO::Objref_Traits<ImplementationRepository::Administration>::duplicate (
    ImplementationRepository::Administration_ptr p)
{
  return ImplementationRepository::Administration::_duplicate (p);
}

void
TAO::Objref_Traits<ImplementationRepository::Administration>::release (
    ImplementationRepository::Administration_ptr p)
{
  ::CORBA::release (p);
}

ImplementationRepository::Administration_ptr
TAO::Objref_Traits<ImplementationRepository::Administration>::nil (void)
{
  return ImplementationRepository::Administration::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<ImplementationRepository::Administration>::marshal (
    const ImplementationRepository::Administration_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::activate_server (
  const char * server)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_Administration_activate_server_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:ImplementationRepository/CannotActivate:1.0",
        ImplementationRepository::CannotActivate::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_CannotActivate
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "activate_server",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_Administration_activate_server_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::add_or_update_server (
  const char * server,
  const ::ImplementationRepository::StartupOptions & options)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);
  TAO::Arg_Traits< ::ImplementationRepository::StartupOptions>::in_arg_val _tao_options (options);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server,
      &_tao_options
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_Administration_add_or_update_server_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "add_or_update_server",
      20,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_Administration_add_or_update_server_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::remove_server (
  const char * server)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_Administration_remove_server_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_server",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_Administration_remove_server_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::shutdown_server (
  const char * server)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_Administration_shutdown_server_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "shutdown_server",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_Administration_shutdown_server_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::server_is_running (
  const char * server,
  const char * partial_ior,
  ::ImplementationRepository::ServerObject_ptr server_object)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);
  TAO::Arg_Traits< char *>::in_arg_val _tao_partial_ior (partial_ior);
  TAO::Arg_Traits< ::ImplementationRepository::ServerObject>::in_arg_val _tao_server_object (server_object);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server,
      &_tao_partial_ior,
      &_tao_server_object
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_Administration_server_is_running_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "server_is_running",
      17,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_Administration_server_is_running_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::server_is_shutting_down (
  const char * server)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_Administration_server_is_shutting_down_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "server_is_shutting_down",
      23,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_Administration_server_is_shutting_down_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::find (
  const char * server,
  ::ImplementationRepository::ServerInformation_out info)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);
  TAO::Arg_Traits< ::ImplementationRepository::ServerInformation>::out_arg_val _tao_info (info);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server,
      &_tao_info
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "find",
      4,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::list (
  ::CORBA::ULong how_many,
  ::CORBA::Boolean determine_active_status,
  ::ImplementationRepository::ServerInformationList_out server_list,
  ::ImplementationRepository::ServerInformationIterator_out server_iterator)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_how_many (how_many);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_determine_active_status (determine_active_status);
  TAO::Arg_Traits< ::ImplementationRepository::ServerInformationList>::out_arg_val _tao_server_list (server_list);
  TAO::Arg_Traits< ::ImplementationRepository::ServerInformationIterator>::out_arg_val _tao_server_iterator (server_iterator);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_how_many,
      &_tao_determine_active_status,
      &_tao_server_list,
      &_tao_server_iterator
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "list",
      4,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::Administration::shutdown (
  ::CORBA::Boolean activators,
  ::CORBA::Boolean servers)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_activators (activators);
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_servers (servers);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_activators,
      &_tao_servers
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "shutdown",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_ONEWAY_INVOCATION
      
    );

  _tao_call.invoke (0, 0);
}

ImplementationRepository::Administration::Administration (void)
{
}

ImplementationRepository::Administration::~Administration (void)
{
}

void
ImplementationRepository::Administration::_tao_any_destructor (void *_tao_void_pointer)
{
  Administration *_tao_tmp_pointer =
    static_cast<Administration *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

ImplementationRepository::Administration_ptr
ImplementationRepository::Administration::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Administration>::narrow (
        _tao_objref,
        "IDL:ImplementationRepository/Administration:1.0");
}

ImplementationRepository::Administration_ptr
ImplementationRepository::Administration::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Administration>::unchecked_narrow (
        _tao_objref);
}

ImplementationRepository::Administration_ptr
ImplementationRepository::Administration::_nil (void)
{
  return 0;
}

ImplementationRepository::Administration_ptr
ImplementationRepository::Administration::_duplicate (Administration_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
ImplementationRepository::Administration::_tao_release (Administration_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
ImplementationRepository::Administration::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:ImplementationRepository/Administration:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* ImplementationRepository::Administration::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/Administration:1.0";
}

::CORBA::Boolean
ImplementationRepository::Administration::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_ImplementationRepository_Administration (
    ::CORBA::tk_objref,
    "IDL:ImplementationRepository/Administration:1.0",
    "Administration");
  

namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_Administration =
    &_tao_tc_ImplementationRepository_Administration;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\interface_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for ImplementationRepository::AdministrationExt.

ImplementationRepository::AdministrationExt_ptr
TAO::Objref_Traits<ImplementationRepository::AdministrationExt>::duplicate (
    ImplementationRepository::AdministrationExt_ptr p)
{
  return ImplementationRepository::AdministrationExt::_duplicate (p);
}

void
TAO::Objref_Traits<ImplementationRepository::AdministrationExt>::release (
    ImplementationRepository::AdministrationExt_ptr p)
{
  ::CORBA::release (p);
}

ImplementationRepository::AdministrationExt_ptr
TAO::Objref_Traits<ImplementationRepository::AdministrationExt>::nil (void)
{
  return ImplementationRepository::AdministrationExt::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<ImplementationRepository::AdministrationExt>::marshal (
    const ImplementationRepository::AdministrationExt_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::AdministrationExt::link_servers (
  const char * server,
  const ::CORBA::StringSeq & peers)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);
  TAO::Arg_Traits< ::CORBA::StringSeq>::in_arg_val _tao_peers (peers);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server,
      &_tao_peers
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_AdministrationExt_link_servers_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:ImplementationRepository/CannotComplete:1.0",
        ImplementationRepository::CannotComplete::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_CannotComplete
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "link_servers",
      12,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_AdministrationExt_link_servers_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::AdministrationExt::kill_server (
  const char * server,
  ::CORBA::Short signum)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);
  TAO::Arg_Traits< ::CORBA::Short>::in_arg_val _tao_signum (signum);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server,
      &_tao_signum
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_AdministrationExt_kill_server_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:ImplementationRepository/CannotComplete:1.0",
        ImplementationRepository::CannotComplete::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_CannotComplete
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "kill_server",
      11,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_AdministrationExt_kill_server_exceptiondata,
      2
    );
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_operation\operation_cs.cpp:88

void
ImplementationRepository::AdministrationExt::force_remove_server (
  const char * server,
  ::CORBA::Short signum)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_server (server);
  TAO::Arg_Traits< ::CORBA::Short>::in_arg_val _tao_signum (signum);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_server,
      &_tao_signum
    };

  static TAO::Exception_Data
  _tao_ImplementationRepository_AdministrationExt_force_remove_server_exceptiondata [] = 
    {
      {
        "IDL:ImplementationRepository/NotFound:1.0",
        ImplementationRepository::NotFound::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_NotFound
#endif /* TAO_HAS_INTERCEPTORS */
      },

      {
        "IDL:ImplementationRepository/CannotComplete:1.0",
        ImplementationRepository::CannotComplete::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ImplementationRepository::_tc_CannotComplete
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "force_remove_server",
      19,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (
      _tao_ImplementationRepository_AdministrationExt_force_remove_server_exceptiondata,
      2
    );
}

ImplementationRepository::AdministrationExt::AdministrationExt (void)
{
}

ImplementationRepository::AdministrationExt::~AdministrationExt (void)
{
}

void
ImplementationRepository::AdministrationExt::_tao_any_destructor (void *_tao_void_pointer)
{
  AdministrationExt *_tao_tmp_pointer =
    static_cast<AdministrationExt *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

ImplementationRepository::AdministrationExt_ptr
ImplementationRepository::AdministrationExt::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AdministrationExt>::narrow (
        _tao_objref,
        "IDL:ImplementationRepository/AdministrationExt:1.0");
}

ImplementationRepository::AdministrationExt_ptr
ImplementationRepository::AdministrationExt::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<AdministrationExt>::unchecked_narrow (
        _tao_objref);
}

ImplementationRepository::AdministrationExt_ptr
ImplementationRepository::AdministrationExt::_nil (void)
{
  return 0;
}

ImplementationRepository::AdministrationExt_ptr
ImplementationRepository::AdministrationExt::_duplicate (AdministrationExt_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
ImplementationRepository::AdministrationExt::_tao_release (AdministrationExt_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
ImplementationRepository::AdministrationExt::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:ImplementationRepository/Administration:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:ImplementationRepository/AdministrationExt:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* ImplementationRepository::AdministrationExt::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/AdministrationExt:1.0";
}

::CORBA::Boolean
ImplementationRepository::AdministrationExt::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_ImplementationRepository_AdministrationExt (
    ::CORBA::tk_objref,
    "IDL:ImplementationRepository/AdministrationExt:1.0",
    "AdministrationExt");
  

namespace ImplementationRepository
{
  ::CORBA::TypeCode_ptr const _tc_AdministrationExt =
    &_tao_tc_ImplementationRepository_AdministrationExt;
}

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\any_op_cs.cpp:38

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<ImplementationRepository::AlreadyRegistered>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  

  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::AlreadyRegistered &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::AlreadyRegistered>::insert_copy (
        _tao_any,
        ::ImplementationRepository::AlreadyRegistered::_tao_any_destructor,
        ::ImplementationRepository::_tc_AlreadyRegistered,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::ImplementationRepository::AlreadyRegistered *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::AlreadyRegistered>::insert (
        _tao_any,
        ::ImplementationRepository::AlreadyRegistered::_tao_any_destructor,
        ::ImplementationRepository::_tc_AlreadyRegistered,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::AlreadyRegistered *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::ImplementationRepository::AlreadyRegistered>::extract (
          _tao_any,
          ::ImplementationRepository::AlreadyRegistered::_tao_any_destructor,
          ::ImplementationRepository::_tc_AlreadyRegistered,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const ImplementationRepository::AlreadyRegistered &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::AlreadyRegistered>::insert_copy (
      _tao_any,
      ImplementationRepository::AlreadyRegistered::_tao_any_destructor,
      ImplementationRepository::_tc_AlreadyRegistered,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::AlreadyRegistered *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::AlreadyRegistered>::insert (
      _tao_any,
      ImplementationRepository::AlreadyRegistered::_tao_any_destructor,
      ImplementationRepository::_tc_AlreadyRegistered,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ImplementationRepository::AlreadyRegistered *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::AlreadyRegistered>::extract (
        _tao_any,
        ImplementationRepository::AlreadyRegistered::_tao_any_destructor,
        ImplementationRepository::_tc_AlreadyRegistered,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\any_op_cs.cpp:38

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<ImplementationRepository::CannotActivate>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  

  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::CannotActivate &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::CannotActivate>::insert_copy (
        _tao_any,
        ::ImplementationRepository::CannotActivate::_tao_any_destructor,
        ::ImplementationRepository::_tc_CannotActivate,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::ImplementationRepository::CannotActivate *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::CannotActivate>::insert (
        _tao_any,
        ::ImplementationRepository::CannotActivate::_tao_any_destructor,
        ::ImplementationRepository::_tc_CannotActivate,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::CannotActivate *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::ImplementationRepository::CannotActivate>::extract (
          _tao_any,
          ::ImplementationRepository::CannotActivate::_tao_any_destructor,
          ::ImplementationRepository::_tc_CannotActivate,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const ImplementationRepository::CannotActivate &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::CannotActivate>::insert_copy (
      _tao_any,
      ImplementationRepository::CannotActivate::_tao_any_destructor,
      ImplementationRepository::_tc_CannotActivate,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::CannotActivate *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::CannotActivate>::insert (
      _tao_any,
      ImplementationRepository::CannotActivate::_tao_any_destructor,
      ImplementationRepository::_tc_CannotActivate,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ImplementationRepository::CannotActivate *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::CannotActivate>::extract (
        _tao_any,
        ImplementationRepository::CannotActivate::_tao_any_destructor,
        ImplementationRepository::_tc_CannotActivate,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\any_op_cs.cpp:38

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<ImplementationRepository::NotFound>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  

  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::NotFound &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::NotFound>::insert_copy (
        _tao_any,
        ::ImplementationRepository::NotFound::_tao_any_destructor,
        ::ImplementationRepository::_tc_NotFound,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::ImplementationRepository::NotFound *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::NotFound>::insert (
        _tao_any,
        ::ImplementationRepository::NotFound::_tao_any_destructor,
        ::ImplementationRepository::_tc_NotFound,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::NotFound *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::ImplementationRepository::NotFound>::extract (
          _tao_any,
          ::ImplementationRepository::NotFound::_tao_any_destructor,
          ::ImplementationRepository::_tc_NotFound,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const ImplementationRepository::NotFound &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::NotFound>::insert_copy (
      _tao_any,
      ImplementationRepository::NotFound::_tao_any_destructor,
      ImplementationRepository::_tc_NotFound,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::NotFound *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::NotFound>::insert (
      _tao_any,
      ImplementationRepository::NotFound::_tao_any_destructor,
      ImplementationRepository::_tc_NotFound,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ImplementationRepository::NotFound *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::NotFound>::extract (
        _tao_any,
        ImplementationRepository::NotFound::_tao_any_destructor,
        ImplementationRepository::_tc_NotFound,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\any_op_cs.cpp:38

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<ImplementationRepository::CannotComplete>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  

  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::CannotComplete &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::CannotComplete>::insert_copy (
        _tao_any,
        ::ImplementationRepository::CannotComplete::_tao_any_destructor,
        ::ImplementationRepository::_tc_CannotComplete,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::ImplementationRepository::CannotComplete *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::CannotComplete>::insert (
        _tao_any,
        ::ImplementationRepository::CannotComplete::_tao_any_destructor,
        ::ImplementationRepository::_tc_CannotComplete,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::CannotComplete *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::ImplementationRepository::CannotComplete>::extract (
          _tao_any,
          ::ImplementationRepository::CannotComplete::_tao_any_destructor,
          ::ImplementationRepository::_tc_CannotComplete,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const ImplementationRepository::CannotComplete &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::CannotComplete>::insert_copy (
      _tao_any,
      ImplementationRepository::CannotComplete::_tao_any_destructor,
      ImplementationRepository::_tc_CannotComplete,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::CannotComplete *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::CannotComplete>::insert (
      _tao_any,
      ImplementationRepository::CannotComplete::_tao_any_destructor,
      ImplementationRepository::_tc_CannotComplete,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ImplementationRepository::CannotComplete *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::CannotComplete>::extract (
        _tao_any,
        ImplementationRepository::CannotComplete::_tao_any_destructor,
        ImplementationRepository::_tc_CannotComplete,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::EnvironmentVariable &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::EnvironmentVariable>::insert_copy (
        _tao_any,
        ::ImplementationRepository::EnvironmentVariable::_tao_any_destructor,
        ::ImplementationRepository::_tc_EnvironmentVariable,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    ImplementationRepository::EnvironmentVariable *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::ImplementationRepository::EnvironmentVariable>::insert (
      _tao_any,
      ::ImplementationRepository::EnvironmentVariable::_tao_any_destructor,
      ::ImplementationRepository::_tc_EnvironmentVariable,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::ImplementationRepository::EnvironmentVariable *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::EnvironmentVariable>::extract (
        _tao_any,
        ::ImplementationRepository::EnvironmentVariable::_tao_any_destructor,
        ::ImplementationRepository::_tc_EnvironmentVariable,
        _tao_elem);
}
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ImplementationRepository::EnvironmentVariable &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::EnvironmentVariable>::insert_copy (
    _tao_any,
    ImplementationRepository::EnvironmentVariable::_tao_any_destructor,
    ImplementationRepository::_tc_EnvironmentVariable,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ImplementationRepository::EnvironmentVariable *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::EnvironmentVariable>::insert (
    _tao_any,
    ImplementationRepository::EnvironmentVariable::_tao_any_destructor,
    ImplementationRepository::_tc_EnvironmentVariable,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ImplementationRepository::EnvironmentVariable *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::EnvironmentVariable>::extract (
      _tao_any,
      ImplementationRepository::EnvironmentVariable::_tao_any_destructor,
      ImplementationRepository::_tc_EnvironmentVariable,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\any_op_cs.cpp:45



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::EnvironmentList &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::EnvironmentList>::insert_copy (
        _tao_any,
        ::ImplementationRepository::EnvironmentList::_tao_any_destructor,
        ::ImplementationRepository::_tc_EnvironmentList,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::ImplementationRepository::EnvironmentList *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::EnvironmentList>::insert (
        _tao_any,
        ::ImplementationRepository::EnvironmentList::_tao_any_destructor,
        ::ImplementationRepository::_tc_EnvironmentList,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::EnvironmentList *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::ImplementationRepository::EnvironmentList>::extract (
          _tao_any,
          ::ImplementationRepository::EnvironmentList::_tao_any_destructor,
          ::ImplementationRepository::_tc_EnvironmentList,
          _tao_elem);
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const ImplementationRepository::EnvironmentList &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::EnvironmentList>::insert_copy (
      _tao_any,
      ImplementationRepository::EnvironmentList::_tao_any_destructor,
      ImplementationRepository::_tc_EnvironmentList,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::EnvironmentList *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::EnvironmentList>::insert (
      _tao_any,
      ImplementationRepository::EnvironmentList::_tao_any_destructor,
      ImplementationRepository::_tc_EnvironmentList,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ImplementationRepository::EnvironmentList *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::EnvironmentList>::extract (
        _tao_any,
        ImplementationRepository::EnvironmentList::_tao_any_destructor,
        ImplementationRepository::_tc_EnvironmentList,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_enum\any_op_cs.cpp:35


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::ImplementationRepository::ActivationMode _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::ImplementationRepository::ActivationMode>::insert (
        _tao_any,
        ::ImplementationRepository::_tc_ActivationMode,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::ImplementationRepository::ActivationMode &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::ImplementationRepository::ActivationMode>::extract (
          _tao_any,
          ::ImplementationRepository::_tc_ActivationMode,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::ActivationMode _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<ImplementationRepository::ActivationMode>::insert (
      _tao_any,
      ImplementationRepository::_tc_ActivationMode,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ImplementationRepository::ActivationMode &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<ImplementationRepository::ActivationMode>::extract (
        _tao_any,
        ImplementationRepository::_tc_ActivationMode,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::StartupOptions &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::StartupOptions>::insert_copy (
        _tao_any,
        ::ImplementationRepository::StartupOptions::_tao_any_destructor,
        ::ImplementationRepository::_tc_StartupOptions,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    ImplementationRepository::StartupOptions *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::ImplementationRepository::StartupOptions>::insert (
      _tao_any,
      ::ImplementationRepository::StartupOptions::_tao_any_destructor,
      ::ImplementationRepository::_tc_StartupOptions,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::ImplementationRepository::StartupOptions *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::StartupOptions>::extract (
        _tao_any,
        ::ImplementationRepository::StartupOptions::_tao_any_destructor,
        ::ImplementationRepository::_tc_StartupOptions,
        _tao_elem);
}
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ImplementationRepository::StartupOptions &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::StartupOptions>::insert_copy (
    _tao_any,
    ImplementationRepository::StartupOptions::_tao_any_destructor,
    ImplementationRepository::_tc_StartupOptions,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ImplementationRepository::StartupOptions *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::StartupOptions>::insert (
    _tao_any,
    ImplementationRepository::StartupOptions::_tao_any_destructor,
    ImplementationRepository::_tc_StartupOptions,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ImplementationRepository::StartupOptions *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::StartupOptions>::extract (
      _tao_any,
      ImplementationRepository::StartupOptions::_tao_any_destructor,
      ImplementationRepository::_tc_StartupOptions,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_enum\any_op_cs.cpp:35


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::ImplementationRepository::ServerActiveStatus _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::ImplementationRepository::ServerActiveStatus>::insert (
        _tao_any,
        ::ImplementationRepository::_tc_ServerActiveStatus,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::ImplementationRepository::ServerActiveStatus &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::ImplementationRepository::ServerActiveStatus>::extract (
          _tao_any,
          ::ImplementationRepository::_tc_ServerActiveStatus,
          _tao_elem 
        );
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::ServerActiveStatus _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<ImplementationRepository::ServerActiveStatus>::insert (
      _tao_any,
      ImplementationRepository::_tc_ServerActiveStatus,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ImplementationRepository::ServerActiveStatus &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<ImplementationRepository::ServerActiveStatus>::extract (
        _tao_any,
        ImplementationRepository::_tc_ServerActiveStatus,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::ServerInformation &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::ServerInformation>::insert_copy (
        _tao_any,
        ::ImplementationRepository::ServerInformation::_tao_any_destructor,
        ::ImplementationRepository::_tc_ServerInformation,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    ImplementationRepository::ServerInformation *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::ImplementationRepository::ServerInformation>::insert (
      _tao_any,
      ::ImplementationRepository::ServerInformation::_tao_any_destructor,
      ::ImplementationRepository::_tc_ServerInformation,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::ImplementationRepository::ServerInformation *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::ServerInformation>::extract (
        _tao_any,
        ::ImplementationRepository::ServerInformation::_tao_any_destructor,
        ::ImplementationRepository::_tc_ServerInformation,
        _tao_elem);
}
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ImplementationRepository::ServerInformation &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::ServerInformation>::insert_copy (
    _tao_any,
    ImplementationRepository::ServerInformation::_tao_any_destructor,
    ImplementationRepository::_tc_ServerInformation,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ImplementationRepository::ServerInformation *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::ServerInformation>::insert (
    _tao_any,
    ImplementationRepository::ServerInformation::_tao_any_destructor,
    ImplementationRepository::_tc_ServerInformation,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ImplementationRepository::ServerInformation *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::ServerInformation>::extract (
      _tao_any,
      ImplementationRepository::ServerInformation::_tao_any_destructor,
      ImplementationRepository::_tc_ServerInformation,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\any_op_cs.cpp:45



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::ServerInformationList &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::ServerInformationList>::insert_copy (
        _tao_any,
        ::ImplementationRepository::ServerInformationList::_tao_any_destructor,
        ::ImplementationRepository::_tc_ServerInformationList,
        _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::ImplementationRepository::ServerInformationList *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::ImplementationRepository::ServerInformationList>::insert (
        _tao_any,
        ::ImplementationRepository::ServerInformationList::_tao_any_destructor,
        ::ImplementationRepository::_tc_ServerInformationList,
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::ImplementationRepository::ServerInformationList *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::ImplementationRepository::ServerInformationList>::extract (
          _tao_any,
          ::ImplementationRepository::ServerInformationList::_tao_any_destructor,
          ::ImplementationRepository::_tc_ServerInformationList,
          _tao_elem);
  }
}

#else



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


/// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const ImplementationRepository::ServerInformationList &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::ServerInformationList>::insert_copy (
      _tao_any,
      ImplementationRepository::ServerInformationList::_tao_any_destructor,
      ImplementationRepository::_tc_ServerInformationList,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::ServerInformationList *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ImplementationRepository::ServerInformationList>::insert (
      _tao_any,
      ImplementationRepository::ServerInformationList::_tao_any_destructor,
      ImplementationRepository::_tc_ServerInformationList,
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ImplementationRepository::ServerInformationList *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<ImplementationRepository::ServerInformationList>::extract (
        _tao_any,
        ImplementationRepository::ServerInformationList::_tao_any_destructor,
        ImplementationRepository::_tc_ServerInformationList,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\any_op_cs.cpp:38

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ImplementationRepository::ServerInformationIterator>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ServerInformationIterator_ptr _tao_elem)
  {
    ServerInformationIterator_ptr _tao_objptr =
      ServerInformationIterator::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      ServerInformationIterator_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<ServerInformationIterator>::insert (
        _tao_any,
        ServerInformationIterator::_tao_any_destructor,
        _tc_ServerInformationIterator,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      ServerInformationIterator_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<ServerInformationIterator>::extract (
          _tao_any,
          ServerInformationIterator::_tao_any_destructor,
          _tc_ServerInformationIterator,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::ServerInformationIterator_ptr _tao_elem)
{
  ImplementationRepository::ServerInformationIterator_ptr _tao_objptr =
    ImplementationRepository::ServerInformationIterator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::ServerInformationIterator_ptr *_tao_elem)
{
  TAO::Any_Impl_T<ImplementationRepository::ServerInformationIterator>::insert (
      _tao_any,
      ImplementationRepository::ServerInformationIterator::_tao_any_destructor,
      ImplementationRepository::_tc_ServerInformationIterator,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ImplementationRepository::ServerInformationIterator_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<ImplementationRepository::ServerInformationIterator>::extract (
        _tao_any,
        ImplementationRepository::ServerInformationIterator::_tao_any_destructor,
        ImplementationRepository::_tc_ServerInformationIterator,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\any_op_cs.cpp:38

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ImplementationRepository::Administration>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Administration_ptr _tao_elem)
  {
    Administration_ptr _tao_objptr =
      Administration::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Administration_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Administration>::insert (
        _tao_any,
        Administration::_tao_any_destructor,
        _tc_Administration,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Administration_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Administration>::extract (
          _tao_any,
          Administration::_tao_any_destructor,
          _tc_Administration,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::Administration_ptr _tao_elem)
{
  ImplementationRepository::Administration_ptr _tao_objptr =
    ImplementationRepository::Administration::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::Administration_ptr *_tao_elem)
{
  TAO::Any_Impl_T<ImplementationRepository::Administration>::insert (
      _tao_any,
      ImplementationRepository::Administration::_tao_any_destructor,
      ImplementationRepository::_tc_Administration,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ImplementationRepository::Administration_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<ImplementationRepository::Administration>::extract (
        _tao_any,
        ImplementationRepository::Administration::_tao_any_destructor,
        ImplementationRepository::_tc_Administration,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\any_op_cs.cpp:38

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ImplementationRepository::AdministrationExt>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace ImplementationRepository
{
  

  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AdministrationExt_ptr _tao_elem)
  {
    AdministrationExt_ptr _tao_objptr =
      AdministrationExt::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AdministrationExt_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AdministrationExt>::insert (
        _tao_any,
        AdministrationExt::_tao_any_destructor,
        _tc_AdministrationExt,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AdministrationExt_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AdministrationExt>::extract (
          _tao_any,
          AdministrationExt::_tao_any_destructor,
          _tc_AdministrationExt,
          _tao_elem);
  }
}

#else


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::AdministrationExt_ptr _tao_elem)
{
  ImplementationRepository::AdministrationExt_ptr _tao_objptr =
    ImplementationRepository::AdministrationExt::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    ImplementationRepository::AdministrationExt_ptr *_tao_elem)
{
  TAO::Any_Impl_T<ImplementationRepository::AdministrationExt>::insert (
      _tao_any,
      ImplementationRepository::AdministrationExt::_tao_any_destructor,
      ImplementationRepository::_tc_AdministrationExt,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ImplementationRepository::AdministrationExt_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<ImplementationRepository::AdministrationExt>::extract (
        _tao_any,
        ImplementationRepository::AdministrationExt::_tao_any_destructor,
        ImplementationRepository::_tc_AdministrationExt,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




#endif

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\cdr_op_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::AlreadyRegistered &_tao_aggregate)
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    ImplementationRepository::AlreadyRegistered&)
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\cdr_op_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::CannotActivate &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::CannotActivate &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\cdr_op_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::NotFound &_tao_aggregate)
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    ImplementationRepository::NotFound&)
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_exception\cdr_op_cs.cpp:48

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::CannotComplete &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::CannotComplete &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:49


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::EnvironmentVariable &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.value.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::EnvironmentVariable &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.value.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_ImplementationRepository_EnvironmentList_CPP_
#define _TAO_CDR_OP_ImplementationRepository_EnvironmentList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::EnvironmentList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::EnvironmentList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_ImplementationRepository_EnvironmentList_CPP_ */

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_enum\cdr_op_cs.cpp:34



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, ImplementationRepository::ActivationMode _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, ImplementationRepository::ActivationMode & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<ImplementationRepository::ActivationMode> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:49


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::StartupOptions &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.command_line.in ()) &&
    (strm << _tao_aggregate.environment) &&
    (strm << _tao_aggregate.working_directory.in ()) &&
    (strm << _tao_aggregate.activation) &&
    (strm << _tao_aggregate.activator.in ()) &&
    (strm << _tao_aggregate.start_limit);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::StartupOptions &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.command_line.out ()) &&
    (strm >> _tao_aggregate.environment) &&
    (strm >> _tao_aggregate.working_directory.out ()) &&
    (strm >> _tao_aggregate.activation) &&
    (strm >> _tao_aggregate.activator.out ()) &&
    (strm >> _tao_aggregate.start_limit);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_enum\cdr_op_cs.cpp:34



TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, ImplementationRepository::ServerActiveStatus _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, ImplementationRepository::ServerActiveStatus & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<ImplementationRepository::ServerActiveStatus> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:49


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::ServerInformation &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.server.in ()) &&
    (strm << _tao_aggregate.startup) &&
    (strm << _tao_aggregate.partial_ior.in ()) &&
    (strm << _tao_aggregate.activeStatus);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::ServerInformation &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.server.out ()) &&
    (strm >> _tao_aggregate.startup) &&
    (strm >> _tao_aggregate.partial_ior.out ()) &&
    (strm >> _tao_aggregate.activeStatus);
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_ImplementationRepository_ServerInformationList_CPP_
#define _TAO_CDR_OP_ImplementationRepository_ServerInformationList_CPP_


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::ServerInformationList &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::ServerInformationList &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


#endif /* _TAO_CDR_OP_ImplementationRepository_ServerInformationList_CPP_ */

// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\cdr_op_cs.cpp:51


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::ServerInformationIterator_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::ServerInformationIterator_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::ImplementationRepository::ServerInformationIterator RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\cdr_op_cs.cpp:51


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::Administration_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::Administration_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::ImplementationRepository::Administration RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// c:\private\datascience\neuralna_mreza\neuralnetwork\ace_wrappers\tao\tao_idl\be\be_visitor_interface\cdr_op_cs.cpp:51


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::AdministrationExt_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::AdministrationExt_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::ImplementationRepository::AdministrationExt RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL





TAO_END_VERSIONED_NAMESPACE_DECL


